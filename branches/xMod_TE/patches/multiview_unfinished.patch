Index: cgame/cg_consolecmds.c
===================================================================
--- cgame/cg_consolecmds.c	(revision 325)
+++ cgame/cg_consolecmds.c	(working copy)
@@ -97,13 +97,19 @@
 		// the scores are more than two seconds out of data,
 		// so request new ones
 		cg.scoresRequestTime = cg.time;
-		trap_SendClientCommand( "score" );
+		
+		// OSPx - we get periodic score updates if we are merging clients
+		if (!cg.demoPlayback && cg.mvTotalClients < 1) {
+			trap_SendClientCommand("score");
+		}
 
 		// leave the current scores up if they were already
 		// displayed, but if this is the first hit, clear them out
 		if ( !cg.showScores ) {
 			cg.showScores = qtrue;
-			cg.numScores = 0;
+			if (!cg.demoPlayback && cg.mvTotalClients < 1) {
+				cg.numScores = 0;
+			}
 		}
 	} else {
 		// show the cached contents even if they just pressed if it
@@ -658,6 +664,14 @@
 	{ "webreports", CG_webReports_f },
 	{ "webinfo", CG_webInfo_f },
 	{ "webadmin", CG_webAdmin_f },
+	{ "mvactivate", CG_mvToggleAll_f },
+	{ "mvdel", CG_mvDelete_f },
+	{ "mvhide", CG_mvHideView_f },
+	{ "mvnew", CG_mvNew_f },
+	{ "mvshow", CG_mvShowView_f },
+	{ "mvswap", CG_mvSwapViews_f },
+	{ "mvtoggle", CG_mvToggleView_f },
+	//{ "spechelp", CG_toggleSpecHelp_f }, // FIXME.. (add it)
 	// -OSPx
 
 	// Arnout
@@ -783,6 +797,11 @@
 	trap_AddCommand("ready");
 	trap_AddCommand("notready");
 	//trap_AddCommand("readyteam"); // Easy to screw up with autocomplete..
+	trap_AddCommand("mvadd");
+	trap_AddCommand("mvaxis");
+	trap_AddCommand("mvallies");
+	trap_AddCommand("mvall");
+	trap_AddCommand("mvnone");
 
 	// Web stuff.. 
 	trap_AddCommand("webbans");	
Index: cgame/cg_draw.c
===================================================================
--- cgame/cg_draw.c	(revision 324)
+++ cgame/cg_draw.c	(working copy)
@@ -1981,7 +1981,10 @@
 			}
 			// jpw
 
-			CG_DrawWeapReticle();
+			// OSPx - multiview
+			if (cg.mvTotalClients < 1 || cg.snap->ps.stats[STAT_HEALTH] > 0) {
+				CG_DrawWeapReticle();
+			}
 			return;
 		}
 		break;
@@ -2562,12 +2565,13 @@
 		ui_disable = qtrue;
 	}
 
-	// should we open the limbo menu
-	if ( cg.snap->ps.pm_type == PM_INTERMISSION ) {
-		test = qfalse;
-	} else {
-		test = cg.snap->ps.pm_flags & PMF_LIMBO || cg.snap->ps.persistant[PERS_TEAM] == TEAM_SPECTATOR || cg.warmup;
-	}
+	// should we open the limbo menu (OSPx - make allowances for MV clients)
+	test = ((cg.snap->ps.pm_flags & PMF_LIMBO) || ((cg.mvTotalClients < 1 && 
+		(
+			(cg.snap->ps.persistant[PERS_TEAM] == TEAM_SPECTATOR) ||
+			(cg.warmup))
+		)
+		&& cg.snap->ps.pm_type != PM_INTERMISSION));
 
 	// auto open/close limbo mode
 	if ( cg_popupLimboMenu.integer ) {
@@ -2652,6 +2656,13 @@
 	str = va( CG_TranslateString( "- Press %s to follow next player" ), str2 );
 	CG_DrawStringExt( x, y, str, color, qtrue, 0, TINYCHAR_WIDTH, TINYCHAR_HEIGHT, 0 );
 	y += TINYCHAR_HEIGHT;
+
+// OSPx - Multivew
+	str2 = BindingFromName("mvactivate");
+	str = va(CG_TranslateString("- Press %s to %s multiview mode"), str2, ((cg.mvTotalClients > 0) ? "disable" : "activate"));
+	CG_DrawStringExt(x, y, str, colorWhite, qtrue, qtrue, TINYCHAR_WIDTH, TINYCHAR_HEIGHT, 0);
+	y += TINYCHAR_HEIGHT;
+// ~OSPx
 }
 
 /*
@@ -2754,6 +2765,11 @@
 	const char  *name;
 	char deploytime[128];        // JPW NERVE
 
+	// MV following info for mainview
+	if (CG_ViewingDraw()) {
+		return(qtrue);
+	}
+
 	if ( !( cg.snap->ps.pm_flags & PMF_FOLLOW ) ) {
 		return qfalse;
 	}
@@ -3025,13 +3041,13 @@
 		}
 	}
 	
-	// OSPx - Speclock
+	// OSPx - Speclock && MV
 	if (int_ui_blackout.integer == 0) {
-		if (cg.snap->ps.powerups[PW_BLACKOUT] > 0) {
+		if (cg.mvTotalClients < 1 && cg.snap->ps.powerups[PW_BLACKOUT] > 0) {
 			trap_Cvar_Set("ui_blackout", va("%d", cg.snap->ps.powerups[PW_BLACKOUT]));
 		}
 	}
-	else if (cg.snap->ps.powerups[PW_BLACKOUT] == 0) {
+	else if (cg.snap->ps.powerups[PW_BLACKOUT] == 0 || cg.mvTotalClients > 0) {
 		trap_Cvar_Set("ui_blackout", "0");
 	}
 
@@ -3864,8 +3880,8 @@
 	if ( cgs.gametype < GT_WOLF ) {
 		return;
 	}
-
-	if ( cg.snap->ps.pm_flags & PMF_LIMBO || cg.snap->ps.persistant[PERS_TEAM] == TEAM_SPECTATOR ) {
+																								// OSPx - MultiView
+	if (cg.snap->ps.pm_flags & PMF_LIMBO || cg.snap->ps.persistant[PERS_TEAM] == TEAM_SPECTATOR || cg.mvTotalClients > 0) {
 		return;
 	}
 
@@ -4083,7 +4099,18 @@
 		CG_DrawLimboMessage();
 		// -NERVE - SMF
 	}
+	else {
+		if (cgs.eventHandling != CGAME_EVENT_NONE) {
+			//			qboolean old = cg.showGameView;
 
+			//			cg.showGameView = qfalse;
+			// draw cursor
+			trap_R_SetColor(NULL);
+			CG_DrawPic(cgDC.cursorx - 14, cgDC.cursory - 14, 32, 32, cgs.media.cursorIcon);
+			//			cg.showGameView = old;
+		}
+	}
+
 	// OSPx - Announcer
 	CG_DrawAnnouncer();
 
Index: cgame/cg_ents.c
===================================================================
--- cgame/cg_ents.c	(revision 304)
+++ cgame/cg_ents.c	(working copy)
@@ -2031,7 +2031,7 @@
 	memset( &ent, 0, sizeof( ent ) );
 
 	// event-only entities will have been dealt with already
-	if ( cent->currentState.eType >= ET_EVENTS ) {
+	if (cent->currentState.eType >= ET_EVENTS && cg.mvTotalClients < 2) {
 		return;
 	}
 
Index: cgame/cg_flamethrower.c
===================================================================
--- cgame/cg_flamethrower.c	(revision 304)
+++ cgame/cg_flamethrower.c	(working copy)
@@ -721,6 +721,11 @@
 	if ( radius < 6 ) {
 		radius = 6;
 	}
+
+	if (CG_CullPointAndRadius(f->org, radius)) {
+		return;
+	}
+
 	rST[0] = radius * 1.0;
 	rST[1] = radius * 1.0 / 1.481;
 	alphaChar = ( unsigned char )( 255.0 * alpha );
Index: cgame/cg_info.c
===================================================================
--- cgame/cg_info.c	(revision 304)
+++ cgame/cg_info.c	(working copy)
@@ -29,6 +29,7 @@
 // cg_info.c -- display information while data is being loading
 
 #include "cg_local.h"
+#include "../ui/ui_shared.h"
 
 #if 0
 #define MAX_LOADING_ITEM_ICONS      26
@@ -584,3 +585,78 @@
 		CG_DrawStringExt(42, 420, s2, colorWhite, qfalse, qtrue, TINYCHAR_WIDTH - 1, TINYCHAR_HEIGHT - 1, 0);
 	}
 }
+
+/*
+	Multiview
+*/
+//
+// Color/font info used for all overlays (below)
+//
+#define COLOR_BG            { 0.1f, 0.1f, 0.1f, 0.4f }
+#define COLOR_BORDER        { 0.1f, 0.1f, 0.1f, 0.8f }
+#define COLOR_BG_TITLE      { 0.16, 0.2f, 0.17f, 0.8f }
+#define COLOR_BG_VIEW       { 0.16, 0.2f, 0.17f, 0.8f }
+#define COLOR_BORDER_TITLE  { 0.1f, 0.1f, 0.1f,  0.2f }
+#define COLOR_BORDER_VIEW   { 0.2f, 0.2f, 0.2f,  0.4f }
+#define COLOR_HDR           { 0.6f, 0.6f, 0.6f,  1.0f }
+#define COLOR_HDR2          { 0.6f, 0.6f, 0.4f,  1.0f }
+#define COLOR_TEXT          { 0.625f, 0.625f, 0.6f,  1.0f }
+
+extern displayContextDef_t cgDC;// L0 - Makes more sense here..	
+
+#define FONT_HEADER         &cgDC.Assets.textFont
+#define FONT_SUBHEADER      &cgDC.Assets.textFont
+#define FONT_TEXT           &cgDC.Assets.textFont
+
+vec4_t color_bg = COLOR_BG_VIEW;
+vec4_t color_border = COLOR_BORDER_VIEW;
+vec4_t color_hdr = COLOR_HDR2;
+vec4_t color_name = COLOR_TEXT;
+
+#define VD_X    4
+#define VD_Y    78
+#define VD_SCALE_X_HDR  0.25f
+#define VD_SCALE_Y_HDR  0.30f
+#define VD_SCALE_X_NAME 0.30f
+#define VD_SCALE_Y_NAME 0.30f
+
+qboolean CG_ViewingDraw() {
+	if (cg.mvTotalClients < 1) {
+		return(qfalse);
+	}
+	else {
+		int w, wTag;
+		int tSpacing = /*15*/ 40;      // Should derive from CG_Text_Height_Ext
+		int pID = cg.mvCurrentMainview->mvInfo & MV_PID;
+		char *viewInfo = "Viewing:";
+
+		wTag = CG_Text_Width_Ext(viewInfo, VD_SCALE_X_HDR, 0, FONT_HEADER);
+		w = wTag + 3 + CG_Text_Width_Ext(cgs.clientinfo[pID].name, VD_SCALE_X_NAME, 0, FONT_TEXT);
+
+		CG_DrawRect(VD_X - 2, VD_Y, w + 7, tSpacing + 4, 1, color_border);
+		CG_FillRect(VD_X - 2, VD_Y, w + 7, tSpacing + 4, color_bg);
+
+		CG_DrawStringExt(VD_X, VD_Y + tSpacing, viewInfo, color_hdr, qtrue, qfalse, 5, 10, 70);
+		CG_DrawStringExt(VD_X + wTag + 5, VD_Y + tSpacing, cgs.clientinfo[pID].name, color_name, qtrue, qfalse, 5, 10, 70);
+
+		/*
+		CG_Text_Paint_Ext(VD_X, VD_Y + tSpacing,            // x, y
+			VD_SCALE_X_HDR, VD_SCALE_Y_HDR,  // scale_x, scale_y
+			color_hdr,
+			viewInfo,
+			0.0f, 0,
+			ITEM_TEXTSTYLE_SHADOWED,
+			FONT_HEADER);
+
+		CG_Text_Paint_Ext(VD_X + wTag + 5, VD_Y + tSpacing, // x, y
+			VD_SCALE_X_NAME, VD_SCALE_Y_NAME, // scale_x, scale_y
+			color_name,
+			cgs.clientinfo[pID].name,
+			0.0f, 0,
+			ITEM_TEXTSTYLE_SHADOWED,
+			FONT_TEXT);
+		*/
+
+		return(qtrue);
+	}
+}
Index: cgame/cg_local.h
===================================================================
--- cgame/cg_local.h	(revision 324)
+++ cgame/cg_local.h	(working copy)
@@ -132,6 +132,7 @@
 #define WFX_TEXTSIZING      0x01    // Size the window based on text/font setting
 #define WFX_FLASH           0x02    // Alternate between bg and b2 every half second
 #define WFX_TRUETYPE        0x04    // Use truetype fonts for text
+#define WFX_MULTIVIEW       0x08    // Multiview window
 // These need to be last
 #define WFX_FADEIN          0x10    // Fade the window in (and back out when closing)
 #define WFX_SCROLLUP        0x20    // Scroll window up from the bottom (and back down when closing)
@@ -144,6 +145,9 @@
 #define WSTATE_SHUTDOWN     0x02    // Window is shutting down with effects
 #define WSTATE_OFF          0x04    // Window is completely shutdown
 
+#define MV_PID              0x00FF  // Bits available for player IDs for MultiView windows
+#define MV_SELECTED         0x0100  // MultiView selected window flag is the 9th bit
+
 typedef struct {
 	vec4_t colorBorder;         // Window border color
 	vec4_t colorBackground;     // Window fill color
@@ -209,6 +213,20 @@
 #define DEMO_RANGEDELTA         6
 #define DEMO_ANGLEDELTA         4
 
+// Multi View
+#define MVINFO_TEXTSIZE     10
+#define MVINFO_RIGHT        640 - 3
+#define MVINFO_TOP          100
+
+typedef struct {
+	int pID;                    // Player ID
+	int classID;                // Player's current class
+	int width;                  // Width of text box
+	char info[8];               // On-screen info (w/color coding)
+	qboolean fActive;           // Overlay element is active
+	cg_window_t *w;         // Window handle (may be NULL)
+} cg_mvinfo_t;
+
 // -OSPx
 
 //=================================================
@@ -697,6 +715,22 @@
 	char headModelName[MAX_QPATH];
 	gender_t gender;                // from model
 	// -NERVE - SMF
+
+// OSPx
+	// MultiView
+	int ammo;
+	int ammoclip;
+	int chargeTime;
+	qboolean fCrewgun;
+	int cursorHint;
+	int grenadeTimeLeft;                // Actual time remaining
+	int grenadeTimeStart;               // Time trigger base to compute TimeLeft
+	int hintTime;
+	int sprintTime;
+	int weapHeat;
+	int weaponState;
+	int weaponState_last;
+// ~OSPx
 } clientInfo_t;
 
 typedef enum {
@@ -905,11 +939,12 @@
 	float zoomSensitivity;
 	float zoomval;
 
-	// OSPx - zoomFOV
+// OSPx - zoomFOV
 	qboolean zoomedFOV;
 	int zoomedTime;
 	float zoomedVal;
 	float zoomedSens;
+// ~OSPx
 
 	// information screen text during loading
 	char infoScreenText[MAX_STRING_CHARS];
@@ -1148,6 +1183,24 @@
 	char popinPrint[1024];
 	int popinPrintLines;
 	qboolean popinBlink;
+
+	// Multiview
+	cg_window_t *mvCurrentActive;       // Client ID of current active window (-1 = none)
+	cg_window_t *mvCurrentMainview;     // Client ID used in the main display (should always be set if mv_cnt > 0)
+	int mvTotalClients;					// Total # of clients available for MV processing
+	int mvTotalTeam[TEAM_NUM_TEAMS];
+	int mv_cnt;							// Number of active MV windows
+	cg_mvinfo_t mvOverlay[MAX_MVCLIENTS];        // Cached info for MV overlay
+	int mvTeamList[TEAM_NUM_TEAMS][MAX_MVCLIENTS];
+	int mvClientList;					// Cached client listing of who is merged	
+	//refdef_t *refdef_current;			// Handling of some drawing elements for MV FIXME - ADD IT (figure out if it is the right one..)
+
+	// FIXME ... Just for test build..
+	int ltChargeTime[2];
+	int soldierChargeTime[2];
+	int engineerChargeTime[2];
+	int medicChargeTime[2];
+
 // -OSPx
 
 	pmoveExt_t pmext;	
@@ -1650,6 +1703,8 @@
 	// Poison
 	qhandle_t poisonOverlay;
 
+	// MV Cursor
+	qhandle_t cursorIcon;
 } cgMedia_t;
 
 // OSPx - Pause states
@@ -1789,7 +1844,14 @@
 	int match_stepTimer;
 
 	// Ready
-	int readyState;
+	int readyState;	
+
+	// Timeout for mouse pointer view
+	int cursorUpdate;
+
+	// Multiview - FIXME - ADD IT (to demo layout..)
+	qboolean fResize;	// MV window "resize" status
+	qboolean fSelect;	// MV window "select" status
 // ~L0
 } cgs_t;
 
@@ -2005,6 +2067,8 @@
 
 // Mappings
 extern vmCvar_t int_ui_blackout;
+extern vmCvar_t int_sensitivity;
+extern vmCvar_t int_m_pitch;
 
 extern vmCvar_t demo_infoWindow;
 extern vmCvar_t demo_controlsWindow;
@@ -2012,6 +2076,8 @@
 extern vmCvar_t demo_notifyWindow;
 extern vmCvar_t demo_showTimein;
 extern vmCvar_t	demo_noAdvertisement;
+
+extern vmCvar_t mv_sensitivity;
 // -OSPx
 
 //
@@ -2022,6 +2088,8 @@
 
 float CG_Cvar_Get( const char *cvar );
 
+int CG_findClientNum(char *s); // OSPx - MultiView Port
+
 void QDECL CG_Printf( const char *msg, ... );
 void QDECL CG_Error( const char *msg, ... );
 
@@ -2054,12 +2122,19 @@
 void CG_ZoomIn_f( void );
 void CG_ZoomOut_f( void );
 void CG_ZoomUp_f( void );
-// OSPx - FOV zoom effect
+
+// OSPx 
+// FOV zoom effect
 void CG_zoomViewSet_f(void);
 void CG_zoomViewRevert_f(void);
 
+// Multiview
+void CG_SetupFrustum(void);
+qboolean CG_CullPoint(vec3_t pt);
+qboolean CG_CullPointAndRadius(const vec3_t pt, vec_t radius);
+// ~OSPx
+
 void CG_DrawActiveFrame( int serverTime, stereoFrame_t stereoView, qboolean demoPlayback );
-
 void CG_Concussive( centity_t *cent );
 //
 // cg_drawtools.c
@@ -2129,6 +2204,8 @@
 extern char teamChat1[256];
 extern char teamChat2[256];
 extern char cg_fxflags;  // JPW NERVE
+void CG_DrawSkyBoxPortal(qboolean fLocalView);
+void CG_OffsetThirdPersonView(void);
 
 void CG_AddLagometerFrameInfo( void );
 void CG_AddLagometerSnapshotInfo( snapshot_t *snap );
@@ -2463,6 +2540,7 @@
 void CG_DemoClick(int key);
 void CG_createControlsWindow(void);
 void CG_demoView(void);
+qboolean CG_ViewingDraw(void);
 
 //
 // cg_scoreboard.c
@@ -2509,6 +2587,7 @@
 void CG_windowFree(cg_window_t *w);
 void CG_windowInit(void);
 void CG_windowNormalizeOnText(cg_window_t *w);
+void CG_cursorUpdate(void);
 
 //
 // L0 - cg_http_cmds.c
@@ -2760,7 +2839,7 @@
 void        CG_FreeCamera( int camNum );
 //----(SA)	end
 
-// L0 - New stuff
+// L0 - New stuff (engine mappings)
 void trap_ReqSS( int quality );
 void trap_HTTP_Submit_cmd(char *url, char *cmd);	
 void trap_HTTP_Post_cmd(char *url, char *cmd);
@@ -2773,6 +2852,32 @@
 // PopIn
 void CG_PopinPrint(const char *str, int y, int charWidth, qboolean blink);
 
+// Multiview
+void CG_mvDelete_f(void);
+void CG_mvHideView_f(void);
+void CG_mvNew_f(void);
+void CG_mvShowView_f(void);
+void CG_mvSwapViews_f(void);
+void CG_mvToggleAll_f(void);
+void CG_mvToggleView_f(void);
+cg_window_t *CG_mvClientLocate(int pID);
+void CG_mvCreate(int pID);
+cg_window_t *CG_mvCurrent(void);
+void CG_mvDraw(cg_window_t *sw);
+cg_window_t *CG_mvFindNonMainview(void);
+void CG_mvFree(int pID);
+void CG_mvMainviewSwap(cg_window_t *av);
+qboolean CG_mvMergedClientLocate(int pID);
+void CG_mvOverlayDisplay(void);
+void CG_mvOverlayUpdate(void);
+void CG_mvOverlayClientUpdate(int pID, int index);
+void CG_mvProcessClientList(void);
+void CG_mvTransitionPlayerState(playerState_t* ps);
+void CG_mvUpdateClientInfo(int pID);
+void CG_mvWindowOverlay(int pID, float b_x, float b_y, float b_w, float b_h, float s, int wState, qboolean fSelected);
+void CG_mvZoomBinoc(float x, float y, float w, float h);
+void CG_mvZoomSniper(float x, float y, float w, float h);
+
 // Ready
 #define CREADY_NONE		0x00
 #define CREADY_AWAITING	0x01
Index: cgame/cg_main.c
===================================================================
--- cgame/cg_main.c	(revision 322)
+++ cgame/cg_main.c	(working copy)
@@ -314,6 +314,8 @@
 
 // Mappings
 vmCvar_t int_ui_blackout;
+vmCvar_t int_sensitivity;
+vmCvar_t int_m_pitch;
 
 vmCvar_t demo_infoWindow;
 vmCvar_t demo_controlsWindow;
@@ -320,6 +322,8 @@
 vmCvar_t demo_popupWindow;
 vmCvar_t demo_showTimein;
 vmCvar_t demo_noAdvertisement;
+
+vmCvar_t mv_sensitivity;
 // -OSPx
 
 typedef struct {
@@ -551,12 +555,16 @@
 	{ &cg_showFlags, "cg_showFlags", "1", CVAR_ARCHIVE },
 
 	{ &int_ui_blackout, "ui_blackout", "0", CVAR_ROM },
+	{ &int_sensitivity, "sensitivity", "5", CVAR_ARCHIVE },
+	{ &int_m_pitch, "m_pitch", "0.022", CVAR_ARCHIVE },
 
 	{ &demo_infoWindow, "demo_infoWindow", "1", CVAR_ARCHIVE },
 	{ &demo_controlsWindow, "demo_controlsWindow", "1", CVAR_ARCHIVE},
 	{ &demo_popupWindow, "demo_popupWindow", "1", CVAR_ARCHIVE },
 	{ &demo_showTimein, "demo_showTimein", "1", CVAR_ARCHIVE },
-	{ &demo_noAdvertisement, "demo_noAdvertisement", "0", CVAR_ARCHIVE }
+	{ &demo_noAdvertisement, "demo_noAdvertisement", "0", CVAR_ARCHIVE },
+
+	{ &mv_sensitivity, "mv_sensitivity", "20", CVAR_ARCHIVE }
 	// -OSPx
 };
 int cvarTableSize = sizeof( cvarTable ) / sizeof( cvarTable[0] );
@@ -671,10 +679,12 @@
 }
 
 int CG_LastAttacker( void ) {
-	if ( !cg.attackerTime ) {
-		return -1;
+	// OSPx - used for messaging clients in the currect active window
+	if (cg.mvTotalClients > 0) {
+		return(cg.mvCurrentActive->mvInfo & MV_PID);
 	}
-	return cg.snap->ps.persistant[PERS_ATTACKER];
+	// OSPx
+	return((!cg.attackerTime) ? -1 : cg.snap->ps.persistant[PERS_ATTACKER]);
 }
 
 void QDECL CG_Printf( const char *msg, ... ) {
@@ -753,7 +763,49 @@
 	return buffer;
 }
 
+/*
+================
+OSPx - MultiView Port
+================
+*/
+int CG_findClientNum(char *s) {
+	int id;
+	char s2[64], n2[64];
+	qboolean fIsNumber = qtrue;
 
+	// See if its a number or string
+	for (id = 0; id < strlen(s) && s[id] != 0; id++) {
+		if (s[id] < '0' || s[id] > '9') {
+			fIsNumber = qfalse;
+			break;
+		}
+	}
+
+	// numeric values are just slot numbers
+	if (fIsNumber) {
+		id = atoi(s);
+		if (id >= 0 && id < cgs.maxclients && cgs.clientinfo[id].infoValid) {
+			return(id);
+		}
+	}
+
+	// check for a name match
+	BG_cleanName(s, s2, sizeof(s2), qfalse);
+	for (id = 0; id < cgs.maxclients; id++) {
+		if (!cgs.clientinfo[id].infoValid) {
+			continue;
+		}
+
+		BG_cleanName(cgs.clientinfo[id].name, n2, sizeof(n2), qfalse);
+		if (!Q_stricmp(n2, s2)) {
+			return(id);
+		}
+	}
+
+	CG_Printf("[cgnotify]%s ^3%s^7 %s.\n", CG_TranslateString("User"), s, CG_TranslateString("is not on the server"));
+	return(-1);
+}
+
 //========================================================================
 void CG_SetupDlightstyles( void ) {
 	int i, j;
@@ -1666,6 +1718,9 @@
 
 	// L0 - NQ smoke
 	InitSmokeSprites();
+
+	// L0 - MV Cursor
+	cgs.media.cursorIcon = trap_R_RegisterShaderNoMip("ui_mp/assets/3_cursor3");
 }
 
 /*
@@ -2415,6 +2470,9 @@
 
 //	cg.weaponSelect = WP_MP40;
 
+	// OSP - sync to main refdef
+	cg.refdef_current = &cg.refdef;
+
 	// get the rendering configuration from the client system
 	trap_GetGlconfig( &cgs.glconfig );
 	cgs.screenXScale = cgs.glconfig.vidWidth / 640.0;
@@ -2438,6 +2496,9 @@
 // OSPx
 	// Reinforcements offset
 	CG_ParseReinforcementTimes(CG_ConfigString(CS_REINFSEEDS));
+
+	// Multiview 
+	CG_windowInit();
 // -OSPx
 
 // JPW NERVE -- pick a direction for smoke drift on the client -- cheap trick because it can be different on different clients, but who cares?
Index: cgame/cg_marks.c
===================================================================
--- cgame/cg_marks.c	(revision 304)
+++ cgame/cg_marks.c	(working copy)
@@ -169,6 +169,12 @@
 		CG_Error( "CG_ImpactMark called with <= 0 radius" );
 	}
 
+	if (temporary) {
+		if (CG_CullPointAndRadius(origin, radius)) {
+			return;
+		}
+	}
+
 	// Ridah, if no duration, use the default
 	if ( duration < 0 ) {
 		if ( duration == -2 ) {
Index: cgame/cg_multiview.c
===================================================================
--- cgame/cg_multiview.c	(revision 0)
+++ cgame/cg_multiview.c	(working copy)
@@ -0,0 +1,877 @@
+/*
+===========================================================================
+
+Wolfenstein: Enemy Territory GPL Source Code
+Copyright (C) 1999-2010 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Wolfenstein: Enemy Territory GPL Source Code (Wolf ET Source Code).  
+
+Wolf ET Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Wolf ET Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Wolf ET Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Wolf: ET Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Wolf ET Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+// cg_multiview.c: Multiview handling
+// ----------------------------------
+// 02 Sep 02
+// rhea@OrangeSmoothie.org
+//
+#include "cg_local.h"
+#include "../ui/ui_shared.h"
+#include "../game/bg_local.h"
+
+void CG_CalcVrect( void );
+void CG_DrawPlayerWeaponIcon( rectDef_t *rect, qboolean drawHighlighted, int align );
+
+
+// Explicit server command to add a view to the client's snapshot
+void CG_mvNew_f( void ) {
+	if ( cg.demoPlayback || trap_Argc() < 2 ) {
+		return;
+	} else {
+		int pID;
+		char aName[64];
+
+		trap_Args( aName, sizeof( aName ) );
+		pID = CG_findClientNum( aName );
+
+		if ( pID >= 0 && !CG_mvMergedClientLocate( pID ) ) {
+			trap_SendClientCommand( va( "mvadd %d\n", pID ) );
+		}
+	}
+}
+
+// Explicit server command to remove a view from the client's snapshot
+void CG_mvDelete_f( void ) {
+	if ( cg.demoPlayback ) {
+		return;
+	} else {
+		int pID = -1;
+
+		if ( trap_Argc() > 1 ) {
+			char aName[64];
+
+			trap_Args( aName, sizeof( aName ) );
+			pID = CG_findClientNum( aName );
+		} else {
+			cg_window_t *w = cg.mvCurrentActive;
+			if ( w != NULL ) {
+				pID = ( w->mvInfo & MV_PID );
+			}
+		}
+
+		if ( pID >= 0 && CG_mvMergedClientLocate( pID ) ) {
+			trap_SendClientCommand( va( "mvdel %d\n", pID ) );
+		}
+	}
+}
+
+
+// Swap highlighted window with main view
+void CG_mvSwapViews_f( void ) {
+	if ( cg.mv_cnt >= 2 && cg.mvCurrentActive != cg.mvCurrentMainview ) {
+		CG_mvMainviewSwap( cg.mvCurrentActive );
+	}
+}
+
+
+// Shut down a window view for a particular MV client
+void CG_mvHideView_f( void ) {
+	if ( cg.mvCurrentActive == NULL || cg.mvCurrentMainview == cg.mvCurrentActive ) {
+		return;
+	}
+
+	CG_mvFree( cg.mvCurrentActive->mvInfo & MV_PID );
+}
+
+
+// Activate a window view for a particular MV client
+void CG_mvShowView_f( void ) {
+	int i;
+
+	for ( i = 0; i < cg.mvTotalClients; i++ ) {
+		if ( cg.mvOverlay[i].fActive ) {
+			if ( cg.mvOverlay[i].w == NULL ) {
+				CG_mvCreate( cg.mvOverlay[i].pID );
+				CG_mvOverlayUpdate();
+			}
+			return;
+		}
+	}
+}
+
+// Toggle a view window on/off
+void CG_mvToggleView_f( void ) {
+	int i;
+
+	for ( i = 0; i < cg.mvTotalClients; i++ ) {
+		if ( cg.mvOverlay[i].fActive ) {
+			if ( cg.mvOverlay[i].w != NULL ) {
+				CG_mvHideView_f();
+			} else {
+				CG_mvCreate( cg.mvOverlay[i].pID );
+				CG_mvOverlayUpdate();
+			}
+			return;
+		}
+	}
+}
+
+// Toggle all views
+void CG_mvToggleAll_f( void ) {
+	if ( !cg.demoPlayback ) {
+		trap_SendClientCommand( ( cg.mvTotalClients > 0 ) ? "mvnone\n" : "mvall\n" );
+	}
+}
+
+
+
+////////////////////////////////////////////////
+//
+// Multiview Primitives
+//
+//
+
+///////////////////////////////
+// Create a new view window
+//
+void CG_mvCreate( int pID ) {
+	cg_window_t *w;
+
+	if ( CG_mvClientLocate( pID ) != NULL ) {
+		return;
+	}
+
+	w = CG_windowAlloc( WFX_MULTIVIEW, 100 );
+	if ( w == NULL ) {
+		return;
+	}
+
+	// Window specific
+	w->id = WID_NONE;
+	w->x = ( cg.mv_cnt == 0 ) ? 0 : 30 + ( 12 * pID );
+	w->y = ( cg.mv_cnt == 0 ) ? 0 : 300 + ( 5 * pID );
+	w->w = ( cg.mv_cnt == 0 ) ? 640 : 128;
+	w->h = ( cg.mv_cnt == 0 ) ? 480 : 96;
+	w->mvInfo = ( pID & MV_PID ) | MV_SELECTED;
+	w->state = ( cg.mv_cnt == 0 ) ? WSTATE_COMPLETE : WSTATE_START;
+
+	if ( cg.mv_cnt == 0 ) {
+		cg.mvCurrentMainview = w;
+		cg.mvCurrentActive = cg.mvCurrentMainview;
+
+		/* FIXME: DO IT
+		if ( cg_specHelp.integer > 0 && !cg.demoPlayback ) {
+			CG_ShowHelp_On( &cg.spechelpWindow );
+		}
+		*/
+	}
+
+	cg.mv_cnt++;
+}
+
+///////////////////////////
+// Delete a view window
+//
+void CG_mvFree( int pID ) {
+	cg_window_t *w = CG_mvClientLocate( pID );
+
+	if ( w != NULL ) {
+		// Free it in mvDraw()
+		w->targetTime = 100;
+		w->time = trap_Milliseconds();
+		w->state = WSTATE_SHUTDOWN;
+	}
+}
+
+cg_window_t *CG_mvClientLocate( int pID ) {
+	int i;
+	cg_window_t *w;
+	cg_windowHandler_t *wh = &cg.winHandler;
+
+	for ( i = 0; i < wh->numActiveWindows; i++ ) {
+		w = &wh->window[wh->activeWindows[i]];
+		if ( ( w->effects & WFX_MULTIVIEW ) && ( w->mvInfo & MV_PID ) == pID ) {
+			return( w );
+		}
+	}
+
+	return( NULL );
+}
+
+// Swap a window-view with the main view
+void CG_mvMainviewSwap( cg_window_t *av ) {
+	int swap_pID = ( cg.mvCurrentMainview->mvInfo & MV_PID );
+
+	cg.mvCurrentMainview->mvInfo = ( cg.mvCurrentMainview->mvInfo & ~MV_PID ) | ( av->mvInfo & MV_PID );
+	av->mvInfo = ( av->mvInfo & ~MV_PID ) | swap_pID;
+
+	CG_mvOverlayUpdate();
+}
+
+
+/////////////////////////////////////////////
+// Track our list of merged clients
+//
+void CG_mvProcessClientList( void ) {
+	int i, bit, newList = cg.snap->ps.powerups[PW_MVCLIENTLIST];
+
+	cg.mvTotalClients = 0;
+
+	for ( i = 0; i < MAX_MVCLIENTS; i++ ) {
+		bit = 1 << i;
+		if ( ( cg.mvClientList & bit ) != ( newList & bit ) ) {
+			if ( ( newList & bit ) == 0 ) {
+				CG_mvFree( i );
+			}
+			// If no active views at all, start up with the first one
+			else if ( cg.mvCurrentMainview == NULL ) {
+				CG_mvCreate( i );
+			}
+		}
+
+		if ( newList & bit ) {
+			cg.mvTotalClients++;
+		}
+	}
+
+	cg.mvClientList = newList;
+	CG_mvOverlayUpdate();
+}
+
+
+// Give handle to the current selected MV window
+cg_window_t *CG_mvCurrent( void ) {
+	int i;
+	cg_window_t *w;
+	cg_windowHandler_t *wh = &cg.winHandler;
+
+	for ( i = 0; i < wh->numActiveWindows; i++ ) {
+		w = &wh->window[wh->activeWindows[i]];
+		if ( ( w->effects & WFX_MULTIVIEW ) && ( w->mvInfo & MV_SELECTED ) ) {
+			return( w );
+		}
+	}
+
+	return( NULL );
+}
+
+// Give handle to any MV window that isnt the mainview
+cg_window_t *CG_mvFindNonMainview( void ) {
+	int i;
+	cg_window_t *w;
+	cg_windowHandler_t *wh = &cg.winHandler;
+
+	// First, find a non-windowed client
+	for ( i = 0; i < cg.mvTotalClients; i++ ) {
+		if ( cg.mvOverlay[i].w == NULL ) {
+			cg.mvCurrentMainview->mvInfo = ( cg.mvCurrentMainview->mvInfo & ~MV_PID ) |
+										   ( cg.mvOverlay[i].pID & MV_PID );
+
+			CG_mvOverlayClientUpdate( cg.mvOverlay[i].pID, i );
+			return( cg.mvCurrentMainview );
+		}
+	}
+
+	// If none available, pull one from a window
+	for ( i = 0; i < wh->numActiveWindows; i++ ) {
+		w = &wh->window[wh->activeWindows[i]];
+		if ( ( w->effects & WFX_MULTIVIEW ) && w != cg.mvCurrentMainview ) {
+			CG_mvMainviewSwap( w );
+			return( w );
+		}
+	}
+
+	return( cg.mvCurrentMainview );
+}
+
+
+
+
+//////////////////////////////////////////////
+//
+//    Rendering/Display Management
+//
+//////////////////////////////////////////////
+
+
+///////////////////////////////////////////////////
+// Update all info for a merged client
+//
+void CG_mvUpdateClientInfo( int pID ) {
+
+	if ( pID >= 0 && pID < MAX_MVCLIENTS && ( cg.mvClientList & ( 1 << pID ) ) ) {
+		int weap = cg_entities[pID].currentState.weapon;
+		int id = MAX_WEAPONS - 1 - ( pID * 2 );
+		clientInfo_t *ci = &cgs.clientinfo[pID];
+		playerState_t *ps = &cg.snap->ps;
+
+		ci->health   = ( ps->ammo[id] )       & 0xFF;
+		ci->hintTime = ( ps->ammo[id] >> 8 )  & 0x0F;
+		ci->weapHeat = ( ps->ammo[id] >> 12 ) & 0x0F;
+
+		ci->ammo        = ( ps->ammo[id - 1] )       & 0x3FF;
+		ci->weaponState = ( ps->ammo[id - 1] >> 11 ) & 0x03;
+		ci->fCrewgun    = ( ps->ammo[id - 1] >> 13 ) & 0x01;
+		ci->cursorHint  = ( ps->ammo[id - 1] >> 14 ) & 0x03;
+
+		ci->ammoclip   = ( ps->ammoclip[id - 1] )       & 0x1FF;
+		ci->chargeTime = ( ps->ammoclip[id - 1] >> 9 )  & 0x0F;
+		ci->sprintTime = ( ps->ammoclip[id - 1] >> 13 ) & 0x07;
+
+		ci->weapHeat   = (int)( 100.0f * (float)ci->weapHeat / 15.0f );
+		ci->chargeTime = ( ci->chargeTime == 0 ) ? -1 : (int)( 100.0f * (float)( ci->chargeTime - 1 ) / 15.0f );
+		ci->hintTime   = ( ci->hintTime == 0 )   ? -1 : (int)( 100.0f * (float)( ci->hintTime - 1 ) / 15.0f );
+		ci->sprintTime = ( ci->sprintTime == 0 ) ? -1 : (int)( 100.0f * (float)( ci->sprintTime - 1 ) / 7.0f );
+
+		if ( ci->health == 0 ) {
+			ci->weaponState = WSTATE_IDLE;
+		}
+
+		// Handle grenade pulsing for the main view
+		if ( ci->weaponState != ci->weaponState_last ) {
+			ci->weaponState_last = ci->weaponState;
+			ci->grenadeTimeStart = ( ci->weaponState == WSTATE_FIRE && ( weap == WP_GRENADE_LAUNCHER || weap == WP_GRENADE_PINEAPPLE ) ) ? 4000 + cg.time : 0;
+		}
+
+		if ( ci->weaponState == WSTATE_FIRE && ( weap == WP_GRENADE_LAUNCHER || weap == WP_GRENADE_PINEAPPLE ) ) {
+			ci->grenadeTimeLeft = ci->grenadeTimeStart - cg.time;
+			if ( ci->grenadeTimeLeft < 0 ) {
+				ci->grenadeTimeLeft = 0;
+			}
+		} else {ci->grenadeTimeLeft = 0;}
+	}
+}
+
+
+////////////////////////////////
+// Updates for main view
+//
+void CG_mvTransitionPlayerState( playerState_t* ps ) {
+	int x, mult, pID = ( cg.mvCurrentMainview->mvInfo & MV_PID );
+	centity_t* cent = &cg_entities[pID];
+	clientInfo_t *ci = &cgs.clientinfo[pID];
+
+	cg.predictedPlayerEntity.currentState = cent->currentState;
+	ps->clientNum = pID;
+	ps->weapon = cent->currentState.weapon;
+	cg.weaponSelect = ps->weapon;
+
+	cent->currentState.eType = ET_PLAYER;
+	ps->eFlags = cent->currentState.eFlags;
+	cg.predictedPlayerState.eFlags = cent->currentState.eFlags;
+	cg.zoomedBinoc = ( ( cent->currentState.eFlags & EF_ZOOMING ) != 0 && ci->health > 0 );
+
+	x = cent->currentState.teamNum;
+	if ( x == PC_MEDIC ) {
+		mult = cg.medicChargeTime[ci->team - 1];
+	} else if ( x == PC_ENGINEER ) {
+		mult = cg.engineerChargeTime[ci->team - 1];
+	} else if ( x == PC_LT )                                                                             {
+		mult = cg.ltChargeTime[ci->team - 1];
+	} else { mult = cg.soldierChargeTime[ci->team - 1];}
+
+	ps->curWeapHeat = (int)( (float)ci->weapHeat * 255.0f / 100.0f );
+	ps->classWeaponTime = ( ci->chargeTime < 0 ) ? -1 : cg.time - (int)( (float)( mult * ci->chargeTime ) / 100.0f );
+
+	ps->sprintTime = (ci->sprintTime < 0) ? 20000 : (int)((float)ci->sprintTime / 100.0f * 20000.0f);
+
+	ps->serverCursorHintVal = ( ci->hintTime < 0 ) ? 0 : ci->hintTime * 255 / 100;
+	ps->serverCursorHint = BG_simpleHintsExpand( ci->cursorHint, ( ( x == 2 ) ? ci->hintTime : -1 ) );
+
+	ps->stats[STAT_HEALTH] = ci->health;
+	ps->stats[STAT_PLAYER_CLASS] = x;
+
+	// Grenade ticks
+	ps->grenadeTimeLeft = ci->grenadeTimeLeft;
+
+	// Safe as we've already pull data before clobbering
+	ps->ammo[BG_FindAmmoForWeapon( ps->weapon )] = ci->ammo;
+	ps->ammoclip[BG_FindClipForWeapon( ps->weapon )] = ci->ammoclip;
+
+	ps->persistant[PERS_SCORE] = ci->score;
+	ps->persistant[PERS_TEAM] = ci->team;
+
+	VectorCopy( cent->lerpOrigin, ps->origin );
+	VectorCopy( cent->lerpAngles, ps->viewangles );
+}
+
+void CG_OffsetThirdPersonView( void );
+
+///////////////////////////////////
+// Draw the client view window
+//
+void CG_mvDraw( cg_window_t *sw ) {
+	int pID = ( sw->mvInfo & MV_PID );
+	int x, base_pID = cg.snap->ps.clientNum;
+	refdef_t refdef;
+	float rd_x, rd_y, rd_w, rd_h;
+	float b_x, b_y, b_w, b_h;
+	float s = 1.0f;
+	centity_t *cent = &cg_entities[pID];
+
+	memset( &refdef, 0, sizeof( refdef_t ) );
+	memcpy( refdef.areamask, cg.snap->areamask, sizeof( refdef.areamask ) );
+
+	CG_mvUpdateClientInfo( pID );
+	cg.snap->ps.clientNum = pID;
+
+	rd_x = sw->x;
+	rd_y = sw->y;
+	rd_w = sw->w;
+	rd_h = sw->h;
+
+	// Cool zoomin/out effect
+	if ( sw->state != WSTATE_COMPLETE ) {
+		int tmp = trap_Milliseconds() - sw->time;
+
+		if ( sw->state == WSTATE_START ) {
+			if ( tmp < sw->targetTime ) {
+				s = (float)tmp / (float)sw->targetTime;
+				rd_x += rd_w * 0.5f * ( 1.0f - s );
+				rd_y += rd_h * 0.5f * ( 1.0f - s );
+				rd_w *= s;
+				rd_h *= s;
+			} else {
+				sw->state = WSTATE_COMPLETE;
+			}
+		} else if ( sw->state == WSTATE_SHUTDOWN ) {
+			if ( tmp < sw->targetTime ) {
+				s = (float)tmp / (float)sw->targetTime;
+				rd_x += rd_w * 0.5f * s;
+				rd_y += rd_h * 0.5f * s;
+				s = 1.0f - s;
+				rd_w *= s;
+				rd_h *= s;
+				if ( sw == cg.mvCurrentMainview ) {
+					trap_R_ClearScene();
+				}
+			} else {
+				// Main window is shutting down.
+				// Try to swap it with another MV client, if available
+				if ( sw == cg.mvCurrentMainview ) {
+					sw = CG_mvFindNonMainview();
+					if ( cg.mvTotalClients > 0 ) {
+						cg.mvCurrentMainview->targetTime = 100;
+						cg.mvCurrentMainview->time = trap_Milliseconds();
+						cg.mvCurrentMainview->state = WSTATE_START;
+					}
+
+					// If we swap with a window, hang around so we can delete the window
+					// Otherwise, if there are still active MV clients, don't close the mainview
+					if ( sw == cg.mvCurrentMainview && cg.mvTotalClients > 0 ) {
+						return;
+					}
+				}
+
+				CG_windowFree( sw );
+
+				// We were on the last viewed client when the shutdown was issued,
+				// go ahead and shut down the mainview window *sniff*
+				if ( --cg.mv_cnt <= 0 ) {
+					cg.mv_cnt = 0;
+					cg.mvCurrentMainview = NULL;
+
+					/* FIXME- ADD IT
+					if ( cg.spechelpWindow == SHOW_ON ) {
+						CG_ShowHelp_Off( &cg.spechelpWindow );
+					}
+					*/
+				}
+
+				CG_mvOverlayUpdate();
+				return;
+			}
+		}
+	}
+
+	b_x = rd_x;
+	b_y = rd_y;
+	b_w = rd_w;
+	b_h = rd_h;
+
+	CG_AdjustFrom640( &rd_x, &rd_y, &rd_w, &rd_h );
+
+	refdef.x = rd_x;
+	refdef.y = rd_y;
+	refdef.width = rd_w;
+	refdef.height = rd_h;
+
+	refdef.fov_x = ( cgs.clientinfo[pID].health > 0 &&
+					 ( /*cent->currentState.weapon == WP_SNIPERRIFLE ||*/ // ARNOUT: this needs updating?
+						 ( cent->currentState.eFlags & EF_ZOOMING ) ) ) ?
+				   cg_zoomDefaultSniper.value :
+				   ( cgs.clientinfo[pID].fCrewgun ) ?
+				   55 : cg_fov.integer;
+
+	x = refdef.width / tan( refdef.fov_x / 360 * M_PI );
+	refdef.fov_y = atan2( refdef.height, x ) * 360 / M_PI;
+
+	refdef.rdflags = cg.refdef.rdflags;
+	refdef.time = cg.time;
+
+	AnglesToAxis( cent->lerpAngles, refdef.viewaxis );
+	VectorCopy( cent->lerpOrigin, refdef.vieworg );
+	VectorCopy( cent->lerpAngles, cg.refdefViewAngles );
+
+	cg.refdef_current = &refdef;
+
+	trap_R_ClearScene();
+
+	if ( sw == cg.mvCurrentMainview && cg.renderingThirdPerson ) {
+		cg.renderingThirdPerson = qtrue;
+//		VectorCopy(cent->lerpOrigin, refdef.vieworg);
+		CG_OffsetThirdPersonView();
+		AnglesToAxis( cg.refdefViewAngles, refdef.viewaxis );
+	} else {
+		cg.renderingThirdPerson = qfalse;
+		refdef.vieworg[2] += ( cent->currentState.eFlags & EF_CROUCHING ) ? CROUCH_VIEWHEIGHT : DEFAULT_VIEWHEIGHT;
+	}
+
+	CG_SetupFrustum();
+	CG_DrawSkyBoxPortal( qfalse );
+
+	if ( !cg.hyperspace ) {
+		CG_AddPacketEntities();
+		CG_AddMarks();
+		CG_AddParticles();
+		CG_AddLocalEntities();
+
+		CG_AddSmokeSprites();
+		//CG_AddAtmosphericEffects();
+
+		CG_AddFlameChunks();
+		CG_AddTrails();     // this must come last, so the trails dropped this frame get drawn
+	}
+
+	if ( sw == cg.mvCurrentMainview ) {
+		CG_DrawActive( STEREO_CENTER );
+		if ( cg.mvCurrentActive == cg.mvCurrentMainview ) {
+			trap_S_Respatialize( cg.clientNum, refdef.vieworg, refdef.viewaxis, qfalse );
+		}
+
+		cg.snap->ps.clientNum = base_pID;
+		cg.refdef_current = &cg.refdef;
+		cg.renderingThirdPerson = qfalse;
+		return;
+	}
+
+	memcpy( refdef.areamask, cg.snap->areamask, sizeof( refdef.areamask ) );
+	refdef.time = cg.time;
+	trap_SetClientLerpOrigin( refdef.vieworg[0], refdef.vieworg[1], refdef.vieworg[2] );
+
+	trap_R_RenderScene( &refdef );
+
+	cg.refdef_current = &cg.refdef;
+
+
+#if 0
+	cg.refdef_current = &refdef;
+	CG_DrawStringExt( 1, 1, ci->name, colorWhite, qtrue, qtrue, 8, 8, 0 );
+	cg.refdef_current = &cg.refdef;
+#endif
+
+	CG_mvWindowOverlay( pID, b_x, b_y, b_w, b_h, s, sw->state, ( sw == cg.mvCurrentActive ) );
+	if ( sw == cg.mvCurrentActive ) {
+		trap_S_Respatialize( cg.clientNum, refdef.vieworg, refdef.viewaxis, qfalse );
+	}
+
+	cg.snap->ps.clientNum = base_pID;
+}
+
+
+////////////////////////////////////////////
+// Simpler overlay for windows
+//
+void CG_mvWindowOverlay( int pID, float b_x, float b_y, float b_w, float b_h, float s, int wState, qboolean fSelected ) {
+	int x;
+	rectDef_t rect;
+	float fw = 8.0f, fh = 8.0f;
+	centity_t *cent = &cg_entities[pID];
+	clientInfo_t *ci = &cgs.clientinfo[pID];
+	const char *p_class = "?";
+	vec4_t *noSelectBorder = &colorDkGrey;
+
+	// Overlays for zoomed views
+	if ( ci->health > 0 ) {
+		/*if(cent->currentState.weapon == WP_SNIPERRIFLE) CG_mvZoomSniper(b_x, b_y, b_w, b_h);	// ARNOUT: this needs updating?
+		else */if ( cent->currentState.eFlags & EF_ZOOMING ) {
+			CG_mvZoomBinoc( b_x, b_y, b_w, b_h );
+		}
+	}
+
+	// Text info
+	fw *= s;
+	fh *= s;
+	x = cent->currentState.teamNum;
+	if ( x == PC_SOLDIER ) {
+		p_class = "^1S"; noSelectBorder = &colorMdRed;
+	} else if ( x == PC_MEDIC )                                                                          {
+		p_class = "^7M"; noSelectBorder = &colorMdGrey;
+	} else if ( x == PC_ENGINEER )                                                                                                                                                        {
+		p_class = "^5E"; noSelectBorder = &colorMdBlue;
+	} else if ( x == PC_LT )                                                                                                                                                                                                                                         {
+		p_class = "^2L"; noSelectBorder = &colorMdGreen;
+	}
+
+	CG_DrawStringExt( b_x + 1, b_y + b_h - ( fh * 2 + 1 + 2 ), ci->name, colorWhite, qfalse, qtrue, fw, fh, 0 );
+	CG_DrawStringExt( b_x + 1, b_y + b_h - ( fh + 2 ), va( "%s^7%d", CG_TranslateString( p_class ), ci->health ), colorWhite, qfalse, qtrue, fw, fh, 0 );
+
+	p_class = va( "%d^1/^7%d", ci->ammoclip, ci->ammo );
+	x = CG_DrawStrlen( p_class );
+	CG_DrawStringExt( b_x + b_w - ( x * fw + 1 ), b_y + b_h - ( fh + 2 ), p_class, colorWhite, qfalse, qtrue, fw, fh, 0 );
+
+
+	// Weapon icon
+	rect.x = b_x + b_w - ( 50 + 1 );
+	rect.y = b_y + b_h - ( 25 + fh + 1 + 2 );
+	rect.w = 50;
+	rect.h = 25;
+	cg.predictedPlayerState.grenadeTimeLeft = 0;
+	cg.predictedPlayerState.weapon = cent->currentState.weapon;
+	CG_DrawPlayerWeaponIcon( &rect, ( ci->weaponState > WSTATE_IDLE ), ITEM_ALIGN_RIGHT );
+
+	// Sprint charge info
+	if ( ci->sprintTime >= 0 ) {
+		p_class = va( "^2S^7%d%%", ci->sprintTime );
+		rect.y -= ( fh + 1 );
+		x = CG_DrawStrlen( p_class );
+		CG_DrawStringExt( b_x + b_w - ( x * fw + 1 ), rect.y, p_class, colorWhite, qfalse, qtrue, fw, fh, 0 );
+	}
+
+	// Weapon charge info
+	if ( ci->chargeTime >= 0 ) {
+		p_class = va( "^1C^7%d%%", ci->chargeTime );
+		rect.y -= ( fh + 1 );
+		x = CG_DrawStrlen( p_class );
+		CG_DrawStringExt( b_x + b_w - ( x * fw + 1 ), rect.y, p_class, colorWhite, qfalse, qtrue, fw, fh, 0 );
+	}
+
+	// Cursorhint work
+	if ( ci->hintTime >= 0 ) {
+		p_class = va( "^3W:^7%d%%", ci->hintTime );
+		rect.y -= ( fh + 1 );
+		x = CG_DrawStrlen( p_class );
+		CG_DrawStringExt( b_x + ( b_w - ( x * ( fw - 1 ) ) ) / 2, b_y + b_h - ( fh + 2 ), p_class, colorWhite, qfalse, qtrue, fw - 1, fh - 1, 0 );
+	}
+
+	// Finally, the window border
+	if ( fSelected && wState == WSTATE_COMPLETE ) {
+		int t = trap_Milliseconds() & 0x07FF;   // 2047
+		float scale;
+		vec4_t borderColor;
+
+		if ( t > 1024 ) {
+			t = 2047 - t;
+		}
+		memcpy( &borderColor, *noSelectBorder, sizeof( vec4_t ) );
+		scale = ( (float)t / 1137.38f ) + 0.5f;
+		if ( scale <= 1.0 ) {
+			borderColor[0] *= scale;
+			borderColor[1] *= scale;
+			borderColor[2] *= scale;
+		} else {
+			scale -= 1.0;
+			borderColor[0] = ( borderColor[0] + scale > 1.0 ) ? 1.0 : borderColor[0] + scale;
+			borderColor[1] = ( borderColor[1] + scale > 1.0 ) ? 1.0 : borderColor[1] + scale;
+			borderColor[2] = ( borderColor[2] + scale > 1.0 ) ? 1.0 : borderColor[2] + scale;
+		}
+		CG_DrawRect( b_x - 1, b_y - 1, b_w + 2, b_h + 2, 2, borderColor );
+	} else {
+		CG_DrawRect( b_x - 1, b_y - 1, b_w + 2, b_h + 2, 2, *noSelectBorder );
+	}
+}
+
+
+
+
+////////////////////////////////////////////////////
+//
+//            MV Text Overlay Handling
+//
+////////////////////////////////////////////////////
+
+char *strClassHighlights[] =
+{
+	S_COLOR_RED,    S_COLOR_MDRED,      // Soldier
+	S_COLOR_WHITE,  S_COLOR_MDGREY,     // Medic
+	S_COLOR_BLUE,   S_COLOR_MDBLUE,     // Engineer
+	S_COLOR_GREEN,  S_COLOR_MDGREEN,    // Lt.
+	S_COLOR_YELLOW, S_COLOR_MDYELLOW    // CovertOps
+};
+
+
+// Update a particular client's info
+void CG_mvOverlayClientUpdate( int pID, int index ) {
+	cg_window_t *w;
+
+	cg.mvOverlay[index].pID = pID;
+	cg.mvOverlay[index].classID = cg_entities[pID].currentState.teamNum;
+	w = CG_mvClientLocate( pID );
+	cg.mvOverlay[index].w = w;
+	if ( w != NULL ) {
+		strcpy( cg.mvOverlay[index].info, va( "%s%s%2d",
+											  strClassHighlights[cg.mvOverlay[index].classID * 2],
+											  ( w == cg.mvCurrentMainview ) ? "*" : "",
+											  pID )
+				);
+	} else {
+		strcpy( cg.mvOverlay[index].info, va( "%s%2d",
+											  strClassHighlights[( cg.mvOverlay[index].classID * 2 ) + 1],
+											  pID )
+				);
+	}
+
+	cg.mvOverlay[index].width = CG_DrawStrlen( cg.mvOverlay[index].info ) * MVINFO_TEXTSIZE;
+}
+
+// Update info on all clients received for display/cursor interaction
+void CG_mvOverlayUpdate( void ) {
+	int i, cnt;
+
+	for ( i = 0, cnt = 0; i < MAX_MVCLIENTS && cnt < cg.mvTotalClients; i++ ) {
+		if ( cg.mvClientList & ( 1 << i ) ) {
+			CG_mvOverlayClientUpdate( i, cnt++ );
+		}
+	}
+}
+
+// See if we have the client in our snapshot
+qboolean CG_mvMergedClientLocate( int pID ) {
+	int i;
+
+	for ( i = 0; i < cg.mvTotalClients; i++ ) {
+		if ( cg.mvOverlay[i].pID == pID ) {
+			return( qtrue );
+		}
+	}
+
+	return( qfalse );
+}
+
+// Display available client info
+void CG_mvOverlayDisplay( void ) {
+	int j, i, x, y, pID;
+	cg_mvinfo_t *o;
+
+
+	if ( cg.mvTotalClients < 1 ) {
+		return;
+	}
+
+	y = MVINFO_TOP - ( 2 * ( MVINFO_TEXTSIZE + 1 ) );
+
+	for ( j = TEAM_RED; j <= TEAM_BLUE; j++ ) {
+		cg.mvTotalTeam[j] = 0;
+		for ( i = 0; i < cg.mvTotalClients; i++ ) {
+			o = &cg.mvOverlay[i];
+			pID = o->pID;
+
+			if ( cgs.clientinfo[pID].team != j ) {
+				continue;
+			}
+
+			if ( cg.mvTotalTeam[j] == 0 ) {
+				char *flag = ( j == TEAM_RED ) ? "ui_mp/assets/ger_flag.tga" : "ui_mp/assets/usa_flag.tga";
+				y += 2 * ( MVINFO_TEXTSIZE + 1 );
+				CG_DrawPic( MVINFO_RIGHT - ( 2 * MVINFO_TEXTSIZE ), y, 2 * MVINFO_TEXTSIZE, MVINFO_TEXTSIZE, trap_R_RegisterShaderNoMip( flag ) );
+			}
+
+			// Update team list info for mouse detection
+			cg.mvTeamList[j][( cg.mvTotalTeam[j] )] = i;
+			cg.mvTotalTeam[j]++;
+
+			// Update any class changes
+			if ( o->classID != cg_entities[pID].currentState.teamNum ) {
+				CG_mvOverlayClientUpdate( o->pID, i );
+			}
+
+			x = MVINFO_RIGHT - o->width;
+			y += MVINFO_TEXTSIZE + 1;
+
+			if ( o->fActive ) {
+				CG_FillRect( x - 1, y, o->width + 2, MVINFO_TEXTSIZE + 2, colorMdYellow );
+
+				// Draw name info only if we're hovering over the text element
+				if ( !( cg.mvCurrentActive->mvInfo & MV_SELECTED ) || cg.mvCurrentActive == cg.mvCurrentMainview ) {
+					int w = CG_DrawStrlen( cgs.clientinfo[pID].name ) * ( MVINFO_TEXTSIZE - 1 );
+
+					CG_FillRect( x - 1 - w - 6, y + 1, w + 2, MVINFO_TEXTSIZE - 1 + 2, colorMdGrey );
+					CG_DrawStringExt( x - w - 6, y + 1,
+									  cgs.clientinfo[pID].name,
+									  colorYellow, qtrue, qtrue,
+									  MVINFO_TEXTSIZE - 1,
+									  MVINFO_TEXTSIZE - 1, 0 );
+				}
+			}
+
+			CG_DrawStringExt( x, y, o->info,
+							  colorWhite, qfalse, qtrue,
+							  MVINFO_TEXTSIZE,
+							  MVINFO_TEXTSIZE, 0 );
+		}
+	}
+}
+
+
+
+//////////////////////////////////////
+//
+// Wolf-specific utilities
+//
+//////////////////////////////////////
+void CG_mvZoomSniper( float x, float y, float w, float h ) {
+	float ws = w / 640;
+	float hs = h / 480;
+
+	// sides
+	CG_FillRect( x, y, 80.0f * ws, 480.0f * hs, colorBlack );
+	CG_FillRect( x + 560.0f * ws, y, 80.0f * ws, 480.0f * hs, colorBlack );
+
+	// center
+	if ( cgs.media.reticleShaderSimple ) {
+		CG_DrawPic( x + 80.0f * ws, y, 480.0f * ws, 480.0f * hs, cgs.media.reticleShaderSimple );
+	}
+
+	// hairs
+	CG_FillRect( x + 84.0f * ws,  y + 239.0f * hs, 177.0f * ws, 2.0f, colorBlack );   // left
+	CG_FillRect( x + 320.0f * ws, y + 242.0f * hs, 1.0f,        58.0f * hs, colorBlack ); // center top
+	CG_FillRect( x + 319.0f * ws, y + 300.0f * hs, 2.0f,        178.0f * hs, colorBlack );    // center bot
+	CG_FillRect( x + 380.0f * ws, y + 239.0f * hs, 177.0f * ws, 2.0f, colorBlack );   // right
+}
+
+
+void CG_mvZoomBinoc( float x, float y, float w, float h ) {
+	float ws = w / 640;
+	float hs = h / 480;
+
+	// an alternative.  This gives nice sharp lines at the expense of a few extra polys
+	if ( cgs.media.binocShaderSimple ) {
+		CG_DrawPic( x, y, 640.0f * ws, 480.0f * ws, cgs.media.binocShaderSimple );
+	}
+
+	CG_FillRect( x + 146.0f * ws, y + 239.0f * hs, 348.0f * ws, 1, colorBlack );
+
+	CG_FillRect( x + 188.0f * ws, y + 234.0f * hs, 1, 13.0f * hs, colorBlack );   // ll
+	CG_FillRect( x + 234.0f * ws, y + 226.0f * hs, 1, 29.0f * hs, colorBlack );   // l
+	CG_FillRect( x + 274.0f * ws, y + 234.0f * hs, 1, 13.0f * hs, colorBlack );   // lr
+	CG_FillRect( x + 320.0f * ws, y + 213.0f * hs, 1, 55.0f * hs, colorBlack );   // center
+	CG_FillRect( x + 360.0f * ws, y + 234.0f * hs, 1, 13.0f * hs, colorBlack );   // rl
+	CG_FillRect( x + 406.0f * ws, y + 226.0f * hs, 1, 29.0f * hs, colorBlack );   // r
+	CG_FillRect( x + 452.0f * ws, y + 234.0f * hs, 1, 13.0f * hs, colorBlack );   // rr
+}
Index: cgame/cg_newDraw.c
===================================================================
--- cgame/cg_newDraw.c	(revision 304)
+++ cgame/cg_newDraw.c	(working copy)
@@ -279,7 +279,7 @@
 CG_DrawPlayerWeaponIcon
 ==============
 */
-static void CG_DrawPlayerWeaponIcon( rectDef_t *rect, qboolean drawHighlighted, int align ) {
+void CG_DrawPlayerWeaponIcon( rectDef_t *rect, qboolean drawHighlighted, int align ) {
 	int size;
 	int realweap;                   // DHM - Nerve
 	qhandle_t icon;
@@ -2492,6 +2492,10 @@
 		else if (cgs.cursorY > 480) {
 			cgs.cursorY = 480;
 		}
+
+		if (x != 0 || y != 0) {
+			cgs.cursorUpdate = cg.time + 5000;
+		}
 		break;
 		default:
 			if ((cg.predictedPlayerState.pm_type == PM_NORMAL ||
@@ -2578,7 +2582,10 @@
 	}
 
 	switch (type) {
-	case CGAME_EVENT_DEMO:		
+	case CGAME_EVENT_DEMO:
+		cgs.fResize = qfalse;
+		cgs.fSelect = qfalse;
+		cgs.cursorUpdate = cg.time + 10000;
 		CG_ScoresUp_f();
 		break;
 	case CGAME_EVENT_NONE:
Index: cgame/cg_playerstate.c
===================================================================
--- cgame/cg_playerstate.c	(revision 304)
+++ cgame/cg_playerstate.c	(working copy)
@@ -537,6 +537,21 @@
 ===============
 */
 void CG_TransitionPlayerState( playerState_t *ps, playerState_t *ops ) {
+	// OSP - MV client handling
+	if (cg.mvTotalClients > 0) {
+		if (ps->clientNum != ops->clientNum) {
+			cg.thisFrameTeleport = qtrue;
+
+			// clear voicechat
+			cg.predictedPlayerEntity.voiceChatSpriteTime = 0;   // CHECKME: should we do this here?
+			cg_entities[ps->clientNum].voiceChatSpriteTime = 0;
+
+			*ops = *ps;
+		}
+		CG_CheckLocalSounds(ps, ops);
+		return;
+	}
+
 	// check for changing follow mode
 	if ( ps->clientNum != ops->clientNum ) {
 		cg.thisFrameTeleport = qtrue;
Index: cgame/cg_predict.c
===================================================================
--- cgame/cg_predict.c	(revision 304)
+++ cgame/cg_predict.c	(working copy)
@@ -35,7 +35,7 @@
 
 #include "cg_local.h"
 
-static pmove_t cg_pmove;
+pmove_t cg_pmove;
 
 static int cg_numSolidEntities;
 static centity_t   *cg_solidEntities[MAX_ENTITIES_IN_SNAPSHOT];
Index: cgame/cg_scoreboard.c
===================================================================
--- cgame/cg_scoreboard.c	(revision 324)
+++ cgame/cg_scoreboard.c	(working copy)
@@ -517,7 +517,7 @@
 	tempx += INFO_PLAYER_WIDTH - offset;
 	// dhm - nerve
 
-	if ( ci->team == TEAM_SPECTATOR ) {
+	if (ci->team == TEAM_SPECTATOR) {
 		const char *s;
 		int w, totalwidth;
 
@@ -526,28 +526,35 @@
 		// OSPx - Show ping for spectators as well
 		s = va("^3(%i) %s", score->ping, CG_TranslateString("SPECTATOR"));
 
-		w = CG_DrawStrlen( s ) * SMALLCHAR_WIDTH;
+		w = CG_DrawStrlen(s) * SMALLCHAR_WIDTH;
 
-		CG_DrawSmallString( tempx + totalwidth - w, y, s, fade );
+		CG_DrawSmallString(tempx + totalwidth - w, y, s, fade);
 		return;
-	} else if ( cg.snap->ps.persistant[PERS_TEAM] == ci->team )   {
+		/*
+		} else if ( cg.snap->ps.persistant[PERS_TEAM] == ci->team )   {
+
 		int val = score->playerClass; // cg_entities[ ci->clientNum ].currentState.teamNum;
 		const char *s;
 
 		if ( val == 0 ) {
-			s = "Soldr";
+		s = "Soldr";
 		} else if ( val == 1 ) {
-			s = "Medic";
+		s = "Medic";
 		} else if ( val == 2 ) {
-			s = "Engr";
+		s = "Engr";
 		} else if ( val == 3 ) {
-			s = "Lieut";
+		s = "Lieut";
 		} else {
-			s = "";
+		s = "";
 		}
 
 		CG_DrawSmallString( tempx, y, CG_TranslateString( s ), fade );
-	}
+		} */
+	// OSPx - allow MV clients see the class of its merged client's on the scoreboard
+	} else if (cg.snap->ps.persistant[PERS_TEAM] == ci->team || CG_mvMergedClientLocate(score->client)) {
+		CG_DrawSmallString(tempx, y, CG_TranslateString(BG_ShortClassnameForNumber(score->playerClass)), fade);
+	} // ~OSPx
+
 	tempx += INFO_CLASS_WIDTH;
 
 	CG_DrawSmallString( tempx, y, va( "%4i", score->score ), fade );
Index: cgame/cg_snapshot.c
===================================================================
--- cgame/cg_snapshot.c	(revision 304)
+++ cgame/cg_snapshot.c	(working copy)
@@ -227,6 +227,11 @@
 		cent->currentValid = qfalse;
 	}
 
+	// OSPx - Multiview
+	if (cg.snap->ps.powerups[PW_MVCLIENTLIST] != cg.mvClientList) {
+		CG_mvProcessClientList();
+	}
+
 	// move nextSnap to snap and do the transitions
 	oldFrame = cg.snap;
 	cg.snap = cg.nextSnap;
@@ -237,8 +242,18 @@
 	for ( i = 0 ; i < cg.snap->numEntities ; i++ ) {
 		cent = &cg_entities[ cg.snap->entities[ i ].number ];
 		CG_TransitionEntity( cent );
+
+		// OSPx - Multiview
+		if (cg.mvTotalClients > 0 && CG_mvMergedClientLocate(cg.snap->entities[i].number)) {
+			CG_mvUpdateClientInfo(cg.snap->entities[i].number);
+		}
 	}
 
+	// OSPx - Multiview
+	if (cg.mvTotalClients > 0) {
+		CG_mvTransitionPlayerState(&cg.snap->ps);
+	}
+
 	cg.nextSnap = NULL;
 
 	// check for playerstate transition events
Index: cgame/cg_view.c
===================================================================
--- cgame/cg_view.c	(revision 322)
+++ cgame/cg_view.c	(working copy)
@@ -275,7 +275,7 @@
 ===============
 */
 #define FOCUS_DISTANCE  512
-static void CG_OffsetThirdPersonView( void ) {
+void CG_OffsetThirdPersonView( void ) {
 	vec3_t forward, right, up;
 	vec3_t view;
 	vec3_t focusAngles;
@@ -1166,7 +1166,7 @@
 ===============
 CG_WaterBlendBlob
 
-L0 - Water effect / OpenwWolf port
+L0 - Water effect / OpenWolf port
 ===============
 */
 
@@ -1221,7 +1221,6 @@
 		}
 	}
 
-
 	// when coming out of water, draw drops
 	if (!inwater && waswater) // init the drops
 	{
@@ -1283,7 +1282,6 @@
 
 		trap_R_AddRefEntityToScene(&ent);
 	}
-
 }
 
 /*
@@ -1635,9 +1633,11 @@
 /*
 ==============
 CG_DrawSkyBoxPortal
+
+// L0 - FIXME - Patch this for Multiview!
 ==============
 */
-void CG_DrawSkyBoxPortal( void ) {
+void CG_DrawSkyBoxPortal(qboolean fLocalView) {
 	static float lastfov = 90;      // for transitions back from zoomed in modes
 	refdef_t backuprefdef;
 	float fov_x;
@@ -1695,7 +1695,6 @@
 		fov_x = 90;
 	}
 
-
 	// setup fog the first time, ignore this part of the configstring after that
 	token = COM_ParseExt( &cstr, qfalse );
 	if ( !token || !token[0] ) {
@@ -1826,9 +1825,6 @@
 		fov_x = 55;
 	}
 
-
-
-
 	cg.refdef.time = cg.time;
 
 	x = cg.refdef.width / tan( fov_x / 360 * M_PI );
@@ -1930,6 +1926,88 @@
 
 //=========================================================================
 
+/*
+**  Frustum code
+*/
+
+// some culling bits
+typedef struct plane_s {
+	vec3_t normal;
+	float dist;
+} plane_t;
+
+static plane_t frustum[4];
+
+//
+//	CG_SetupFrustum
+//
+void CG_SetupFrustum(void) {
+	int i;
+	float xs, xc;
+	float ang;
+
+	ang = cg.refdef_current->fov_x / 180 * M_PI * 0.5f;
+	xs = sin(ang);
+	xc = cos(ang);
+
+	VectorScale(cg.refdef_current->viewaxis[0], xs, frustum[0].normal);
+	VectorMA(frustum[0].normal, xc, cg.refdef_current->viewaxis[1], frustum[0].normal);
+
+	VectorScale(cg.refdef_current->viewaxis[0], xs, frustum[1].normal);
+	VectorMA(frustum[1].normal, -xc, cg.refdef_current->viewaxis[1], frustum[1].normal);
+
+	ang = cg.refdef.fov_y / 180 * M_PI * 0.5f;
+	xs = sin(ang);
+	xc = cos(ang);
+
+	VectorScale(cg.refdef_current->viewaxis[0], xs, frustum[2].normal);
+	VectorMA(frustum[2].normal, xc, cg.refdef_current->viewaxis[2], frustum[2].normal);
+
+	VectorScale(cg.refdef_current->viewaxis[0], xs, frustum[3].normal);
+	VectorMA(frustum[3].normal, -xc, cg.refdef_current->viewaxis[2], frustum[3].normal);
+
+	for (i = 0; i < 4; i++) {
+		frustum[i].dist = DotProduct(cg.refdef_current->vieworg, frustum[i].normal);
+	}
+}
+
+//
+//	CG_CullPoint - returns true if culled
+//
+qboolean CG_CullPoint(vec3_t pt) {
+	int i;
+	plane_t *frust;
+
+	// check against frustum planes
+	for (i = 0; i < 4; i++) {
+		frust = &frustum[i];
+
+		if ((DotProduct(pt, frust->normal) - frust->dist) < 0) {
+			return(qtrue);
+		}
+	}
+
+	return(qfalse);
+}
+
+qboolean CG_CullPointAndRadius(const vec3_t pt, vec_t radius) {
+	int i;
+	plane_t *frust;
+
+	// check against frustum planes
+	for (i = 0; i < 4; i++) {
+		frust = &frustum[i];
+
+		if ((DotProduct(pt, frust->normal) - frust->dist) < -radius) {
+			return(qtrue);
+		}
+	}
+
+	return(qfalse);
+}
+
+//=========================================================================
+
 extern void CG_SetupDlightstyles( void );
 
 
@@ -2036,129 +2114,146 @@
 
 	DEBUGTIME
 
-	// decide on third person view
-	cg.renderingThirdPerson = cg_thirdPerson.integer || ( cg.snap->ps.stats[STAT_HEALTH] <= 0 );
+// OSPx -- MultiView
+	if (cg.mvCurrentMainview != NULL && cg.snap->ps.pm_type != PM_INTERMISSION) {
+		CG_mvDraw(cg.mvCurrentMainview);
+		// FIXME: not valid for demo playback
+		cg.zoomSensitivity = mv_sensitivity.value / int_sensitivity.value;
+	}
+	else {
+		// clear all the render lists
+		trap_R_ClearScene();
 
-	// build cg.refdef
-	inwater = CG_CalcViewValues();
+		DEBUGTIME			
 
-	DEBUGTIME
+		// decide on third person view
+		cg.renderingThirdPerson = cg_thirdPerson.integer || (cg.snap->ps.stats[STAT_HEALTH] <= 0);
 
-	// RF, draw the skyboxportal
-	CG_DrawSkyBoxPortal();
+		// build cg.refdef
+		inwater = CG_CalcViewValues();
+		CG_SetupFrustum(); // OSPx - MultiView
 
-	DEBUGTIME
+		DEBUGTIME
 
-	if ( inwater ) {
-		CG_UnderwaterSounds();
-	}
+		// RF, draw the skyboxportal
+		CG_DrawSkyBoxPortal(qtrue);
 
-	DEBUGTIME
+		DEBUGTIME
 
-	// first person blend blobs, done after AnglesToAxis
-	if ( !cg.renderingThirdPerson ) {
-		CG_DamageBlendBlob();
-		// L0 - Water effect
-		CG_WaterBlendBlob(inwater);
-	}
+		if (inwater) {
+			CG_UnderwaterSounds();
+		}
 
-	DEBUGTIME
+		DEBUGTIME
 
-	// build the render lists
-	if ( !cg.hyperspace ) {
-		CG_AddPacketEntities();         // adter calcViewValues, so predicted player state is correct
-		CG_AddMarks();
+		// first person blend blobs, done after AnglesToAxis
+		if (!cg.renderingThirdPerson) {
+			CG_DamageBlendBlob();
+			// L0 - Water effect
+			CG_WaterBlendBlob(inwater);
+		}
 
 		DEBUGTIME
 
-		// Rafael particles
-		CG_AddParticles();
-		// done.
+		// build the render lists
+		if (!cg.hyperspace) {
+			CG_AddPacketEntities();         // adter calcViewValues, so predicted player state is correct
+			CG_AddMarks();
 
 		DEBUGTIME
 
-		CG_AddLocalEntities();
+			// Rafael particles
+			CG_AddParticles();
+			// done.
 
 		DEBUGTIME
 
-		// L0 - NQ smoke
-		// If you are planning to use smoke then note that you have to
-		// sort it out since dyno planting is currently using same bits
-		// thus on 1.0 it would produce smoke when dyno is planted..
-		// Basically i'm leaving this in for any modders but commenting it out.
-		//CG_AddSmokeSprites();
-	}
-	// Rafael mg42
-	if ( !( cg.snap->ps.persistant[PERS_HWEAPON_USE] ) ) {
-		CG_AddViewWeapon( &cg.predictedPlayerState );
-	}
+			CG_AddLocalEntities();
 
-	// NERVE - SMF - play buffered voice chats
-	CG_PlayBufferedVoiceChats();
+		DEBUGTIME
 
-	DEBUGTIME
-/*
-	if (cg_notebook.integer)
-	{
-		CG_DrawNotebook ();
-	}
-*/
-	DEBUGTIME
+			// L0 - NQ smoke
+			// If you are planning to use smoke then note that you have to
+			// sort it out since dyno planting is currently using same bits
+			// thus on 1.0 it would produce smoke when dyno is planted..
+			// Basically i'm leaving this in for any modders but commenting it out.
+			//CG_AddSmokeSprites();
+		}
 
-	// Ridah, trails
-	if ( !cg.hyperspace ) {
-		CG_AddFlameChunks();
-		CG_AddTrails();         // this must come last, so the trails dropped this frame get drawn
-	}
-	// done.
+		// Rafael mg42
+		if (!(cg.snap->ps.persistant[PERS_HWEAPON_USE])) {
+			CG_AddViewWeapon(&cg.predictedPlayerState);
+		}
 
-	DEBUGTIME
+		// NERVE - SMF - play buffered voice chats
+		CG_PlayBufferedVoiceChats();
 
-	// finish up the rest of the refdef
-	if ( cg.testModelEntity.hModel ) {
-		CG_AddTestModel();
-	}
-	cg.refdef.time = cg.time;
-	memcpy( cg.refdef.areamask, cg.snap->areamask, sizeof( cg.refdef.areamask ) );
+		DEBUGTIME
+		/*
+		if (cg_notebook.integer)
+		{
+			CG_DrawNotebook ();
+		}
+		*/
+		DEBUGTIME
 
-	DEBUGTIME
+		// Ridah, trails
+		if (!cg.hyperspace) {
+			CG_AddFlameChunks();
+			CG_AddTrails();         // this must come last, so the trails dropped this frame get drawn
+		}
+		// done.
 
-	// warning sounds when powerup is wearing off
-	//CG_PowerupTimerSounds();
+		DEBUGTIME
 
-	// make sure the lagometerSample and frame timing isn't done twice when in stereo
-	if ( stereoView != STEREO_RIGHT ) {
-		cg.frametime = cg.time - cg.oldTime;
-		if ( cg.frametime < 0 ) {
-			cg.frametime = 0;
+		// finish up the rest of the refdef
+		if (cg.testModelEntity.hModel) {
+			CG_AddTestModel();
 		}
-		cg.oldTime = cg.time;
-		CG_AddLagometerFrameInfo();
-	}
 
-	DEBUGTIME
+		cg.refdef.time = cg.time;
+		memcpy(cg.refdef.areamask, cg.snap->areamask, sizeof(cg.refdef.areamask));
 
-	// Ridah, fade the screen
-	CG_DrawScreenFade();
+		DEBUGTIME
 
-	DEBUGTIME
+		// warning sounds when powerup is wearing off
+		//CG_PowerupTimerSounds();
 
-	mpSetup = CG_GetMPSetupValue();     // NERVE - SMF - setup mpSetup values
+		// make sure the lagometerSample and frame timing isn't done twice when in stereo
+		if (stereoView != STEREO_RIGHT) {
+			cg.frametime = cg.time - cg.oldTime;
 
-	// let the client system know what our weapon, holdable item and zoom settings are
-	trap_SetUserCmdValue( cg.weaponSelect, cg.holdableSelect, cg.zoomSensitivity, mpSetup, cg.identifyClientRequest );
+			if (cg.frametime < 0) {
+				cg.frametime = 0;
+			}
+			cg.oldTime = cg.time;
+			CG_AddLagometerFrameInfo();
+		}
 
-	// DHM - Nerve :: let client system know our predicted origin
-	trap_SetClientLerpOrigin( cg.refdef.vieworg[0], cg.refdef.vieworg[1], cg.refdef.vieworg[2] );
+		DEBUGTIME
 
-	// actually issue the rendering calls
-	CG_DrawActive( stereoView );
+		// Ridah, fade the screen
+		CG_DrawScreenFade();
 
-	DEBUGTIME
+		DEBUGTIME
 
-	// update audio positions
-	trap_S_Respatialize( cg.snap->ps.clientNum, cg.refdef.vieworg, cg.refdef.viewaxis, inwater );
+		mpSetup = CG_GetMPSetupValue();     // NERVE - SMF - setup mpSetup values
 
+		// let the client system know what our weapon, holdable item and zoom settings are
+		trap_SetUserCmdValue(cg.weaponSelect, cg.holdableSelect, cg.zoomSensitivity, mpSetup, cg.identifyClientRequest);
+
+		// DHM - Nerve :: let client system know our predicted origin
+		trap_SetClientLerpOrigin(cg.refdef.vieworg[0], cg.refdef.vieworg[1], cg.refdef.vieworg[2]);
+
+		// actually issue the rendering calls
+		CG_DrawActive(stereoView);
+
+		DEBUGTIME
+
+		// update audio positions
+		trap_S_Respatialize(cg.snap->ps.clientNum, cg.refdef.vieworg, cg.refdef.viewaxis, inwater);
+	} // ~OSPx - End MV wrapper..
+
 	if ( cg_stats.integer ) {
 		CG_Printf( "cg.clientFrame:%i\n", cg.clientFrame );
 	}
Index: cgame/cg_weapons.c
===================================================================
--- cgame/cg_weapons.c	(revision 316)
+++ cgame/cg_weapons.c	(working copy)
@@ -3601,7 +3601,8 @@
 	if ( !cg.snap ) {
 		return;
 	}
-	if ( cg.snap->ps.pm_flags & PMF_FOLLOW ) {
+	// Overload for spec mode when following
+	if ((cg.snap->ps.pm_flags & PMF_FOLLOW) || cg.mvTotalClients > 0) {
 		return;
 	}
 
@@ -3974,6 +3975,13 @@
 	if ( !cg.snap ) {
 		return;
 	}
+
+	// OSPx - Multivew / Overload for MV clients
+	if (cg.mvTotalClients > 0) {
+		CG_mvToggleView_f();
+		return;
+	}
+
 	// OSPx - Pause
 	if (cg.snap->ps.pm_type == PM_FREEZE) {
 		return;
@@ -4025,6 +4033,13 @@
 	if ( !cg.snap ) {
 		return;
 	}
+
+	// OSPx - Multiview - Overload for MV clients
+	if (cg.mvTotalClients > 0) {
+		CG_mvSwapViews_f();
+		return;
+	}
+
 	// OSPx - Pause
 	if (cg.snap->ps.pm_type == PM_FREEZE) {
 		return;
Index: cgame/cg_window.c
===================================================================
--- cgame/cg_window.c	(revision 304)
+++ cgame/cg_window.c	(working copy)
@@ -241,6 +241,7 @@
 	int h, x, y, i, j, milli, t_offset, tmp;
 	cg_window_t *w;
 	qboolean fCleanup = qfalse;
+	qboolean fAllowMV = (cg.snap != NULL && cg.snap->ps.pm_type != PM_INTERMISSION /*&& !cg.limboMenu*/);
 	vec4_t *bg;
 	vec4_t textColor, borderColor, bgColor;
 
@@ -265,6 +266,12 @@
 	milli = trap_Milliseconds();
 	memcpy( textColor, colorWhite, sizeof( vec4_t ) );
 
+	// Mouse cursor position for MV highlighting (offset for cursor pointer position)
+	// Also allow for swingcam toggling
+	if (cg.mvTotalClients > 0 && fAllowMV) {
+		CG_cursorUpdate();
+	}
+
 	for ( i = 0; i < cg.winHandler.numActiveWindows; i++ ) {
 		w = &cg.winHandler.window[cg.winHandler.activeWindows[i]];
 
@@ -273,6 +280,14 @@
 			continue;
 		}
 
+		// Multiview rendering has its own handling
+		if (w->effects & WFX_MULTIVIEW) {
+			if (w != cg.mvCurrentMainview && fAllowMV) {
+				CG_mvDraw(w);
+			}
+			continue;
+		}
+
 		if ( w->effects & WFX_TEXTSIZING ) {
 			CG_windowNormalizeOnText( w );
 			w->effects &= ~WFX_TEXTSIZING;
@@ -394,11 +409,21 @@
 		}
 	}
 
+	// Wedge in MV info overlay
+	if (cg.mvTotalClients > 0 && fAllowMV) {
+		CG_mvOverlayDisplay();
+	}
+
 // OSPx 
 	// Track this..
 	CG_destroyDemoPopUpWindow();
 // ~OSPx
 
+	// Mouse cursor lays on top of everything
+	if (cg.mvTotalClients > 0 && cg.time < cgs.cursorUpdate && fAllowMV) {
+		CG_DrawPic(cgs.cursorX - 10, cgs.cursorY - 10, 32, 32, cgs.media.cursorIcon);
+	}
+
 	if ( fCleanup ) {
 		CG_windowCleanup();
 	}
@@ -557,3 +582,221 @@
 	}
 }
 
+//
+// cgame cursor handling
+//
+
+// Mouse overlay for controlling multiview windows
+void CG_cursorUpdate(void) {
+	int i, j, x;
+	float nx, ny;
+	int nSelectedWindow = -1;
+	cg_window_t *w;
+	cg_windowHandler_t *wh = &cg.winHandler;
+	qboolean fFound = qfalse, fUpdateOverlay = qfalse;
+	qboolean fSelect, fResize;
+
+
+	// Get cursor current position (when connected to a server)
+	if (!cg.demoPlayback) {
+
+		// Allow for limbo'd updates as well
+		trap_GetUserCmd(trap_GetCurrentCmdNumber(), &cg_pmove.cmd);
+
+		nx = 640.0 * (65536.0 - cg_pmove.cmd.angles[1]) / 65536.0;
+		ny = 480.0 / 65536.0 * ((int_m_pitch.value < 0.0) ? (65536.0 - cg_pmove.cmd.angles[0]) : cg_pmove.cmd.angles[0]);
+
+		fSelect = ((cg_pmove.cmd.buttons & BUTTON_ATTACK) != 0);
+
+		if (cgs.cursorX == (int)nx  && cgs.cursorY == (int)ny && !fSelect) {
+			return;
+		}
+
+		fResize = ((cg_pmove.cmd.buttons & BUTTON_SPRINT) != 0);
+
+		cgs.cursorUpdate = cg.time + 5000;
+		cgs.cursorX = nx;
+		cgs.cursorY = ny;
+	}
+	else {
+		// Already updated in the keycatcher
+		nx = cgs.cursorX;
+		ny = cgs.cursorY;
+		fSelect = cgs.fSelect;
+		fResize = cgs.fResize;
+	}
+
+	// For mm4
+	cg.mvCurrentActive = cg.mvCurrentMainview;
+
+	// For overlay highlights
+	for (i = 0; i < cg.mvTotalClients; i++) {
+		cg.mvOverlay[i].fActive = qfalse;
+	}
+
+	for (i = wh->numActiveWindows - 1; i >= 0; i--) {
+		w = &wh->window[wh->activeWindows[i]];
+		if ((w->effects & WFX_MULTIVIEW) && w != cg.mvCurrentMainview) {
+			// Mouse/window detection
+			// If the current window is selected, and the button is down, then allow the update
+			// to occur, as quick mouse movements can move it past the window borders
+			if (!fFound &&
+				(
+				((w->mvInfo & MV_SELECTED) && fSelect) ||
+				(!fSelect && nx >= w->x && nx < w->x + w->w && ny >= w->y && ny < w->y + w->h)
+				)) {
+				if (!(w->mvInfo & MV_SELECTED)) {
+					w->mvInfo |= MV_SELECTED;
+					nSelectedWindow = i;
+				}
+
+				// If not dragging/resizing, prime for later update
+				if (!fSelect) {
+					w->m_x = -1.0f;
+					w->m_y = -1.0f;
+				}
+				else {
+					if (w->m_x > 0 && w->m_y > 0) {
+						if (fResize) {
+							w->w += nx - w->m_x;
+							if (w->x + w->w > 640 - 2) {
+								w->w = 640 - 2 - w->x;
+							}
+							if (w->w < 64) {
+								w->w = 64;
+							}
+
+							w->h += ny - w->m_y;
+							if (w->y + w->h > 480 - 2) {
+								w->h = 480 - 2 - w->y;
+							}
+							if (w->h < 48) {
+								w->h = 48;
+							}
+						}
+						else {
+							w->x += nx - w->m_x;
+							if (w->x + w->w > 640 - 2) {
+								w->x = 640 - 2 - w->w;
+							}
+							if (w->x < 2) {
+								w->x = 2;
+							}
+
+							w->y += ny - w->m_y;
+							if (w->y + w->h > 480 - 2) {
+								w->y = 480 - 2 - w->h;
+							}
+							if (w->y < 2) {
+								w->y = 2;
+							}
+						}
+					}
+
+					w->m_x = nx;
+					w->m_y = ny;
+				}
+
+				fFound = qtrue;
+				cg.mvCurrentActive = w;
+
+				// Reset mouse info for window if it loses focuse
+			}
+			else if (w->mvInfo & MV_SELECTED) {
+				fUpdateOverlay = qtrue;
+				w->m_x = -1.0f;
+				w->m_y = -1.0f;
+				w->mvInfo &= ~MV_SELECTED;
+
+				if (fFound) {
+					break;              // Small optimization: we've found a new window, and cleared the old focus
+				}
+			}
+		}
+	}
+
+	nx = (float)(MVINFO_RIGHT - (MVINFO_TEXTSIZE * 3));
+	ny = (float)(MVINFO_TOP + (MVINFO_TEXTSIZE + 1));
+
+	// Highlight corresponding active window's overlay element
+	if (fFound) {
+		for (i = 0; i < cg.mvTotalClients; i++) {
+			if (cg.mvOverlay[i].pID == (cg.mvCurrentActive->mvInfo & MV_PID)) {
+				cg.mvOverlay[i].fActive = qtrue;
+				break;
+			}
+		}
+	}
+	// Check MV overlay detection here for better perf with more text elements
+	// General boundary check
+	else {
+		// Ugh, have to loop through BOTH team lists
+		int vOffset = 0;
+
+		for (i = TEAM_RED; i <= TEAM_BLUE; i++) {
+			if (cg.mvTotalTeam[i] == 0) {
+				continue;
+			}
+			if (cgs.cursorX >= nx && cgs.cursorY >= ny && cgs.cursorX < MVINFO_RIGHT &&
+				cgs.cursorY < ny + (cg.mvTotalTeam[i] * (MVINFO_TEXTSIZE + 1))) {
+				int pos = (int)(cgs.cursorY - ny) / (MVINFO_TEXTSIZE + 1);
+
+				if (pos < cg.mvTotalTeam[i]) {
+					int x = MVINFO_RIGHT - cg.mvOverlay[(cg.mvTeamList[i][pos])].width;
+					int y = MVINFO_TOP + vOffset + ((pos + 1) * (MVINFO_TEXTSIZE + 1));
+
+					// See if we're really over something
+					if (cgs.cursorX >= x && cgs.cursorY >= y &&
+						cgs.cursorX <= MVINFO_RIGHT &&
+						cgs.cursorY <= y + MVINFO_TEXTSIZE) {
+						// Perform any other window handling here for MV
+						// views based on element selection
+						cg.mvOverlay[(cg.mvTeamList[i][pos])].fActive = qtrue;
+
+						w = CG_mvClientLocate(cg.mvOverlay[(cg.mvTeamList[i][pos])].pID);
+						if (w != NULL) {
+							cg.mvCurrentActive = w;
+						}
+
+						if (fSelect) {
+							if (w != NULL) {
+								// Swap window-view with mainview
+								if (w != cg.mvCurrentMainview) {
+									CG_mvMainviewSwap(w);
+								}
+							}
+							else {
+								// Swap non-view with mainview
+								cg.mvCurrentMainview->mvInfo = (cg.mvCurrentMainview->mvInfo & ~MV_PID) |
+									(cg.mvOverlay[cg.mvTeamList[i][pos]].pID & MV_PID);
+								fUpdateOverlay = qtrue;
+							}
+						}
+					}
+				}
+			}
+			vOffset += (cg.mvTotalTeam[i] + 2) * (MVINFO_TEXTSIZE + 1);
+			ny += vOffset;
+		}
+	}
+
+	// If we have a new highlight, reorder so our highlight is always
+	// drawn last (on top of all other windows)
+	if (nSelectedWindow >= 0) {
+		fUpdateOverlay = qtrue;
+		x = wh->activeWindows[nSelectedWindow];
+
+		for (j = nSelectedWindow; j < wh->numActiveWindows - 1; j++) {
+			wh->activeWindows[j] = wh->activeWindows[j + 1];
+		}
+
+		wh->activeWindows[wh->numActiveWindows - 1] = x;
+	}
+
+	// Finally, sync the overlay, if needed
+	if (fUpdateOverlay) {
+		CG_mvOverlayUpdate();
+	}
+}
+
+
Index: cgame/cgame.vcxproj
===================================================================
--- cgame/cgame.vcxproj	(revision 304)
+++ cgame/cgame.vcxproj	(working copy)
@@ -11,7 +11,7 @@
     </ProjectConfiguration>
   </ItemGroup>
   <PropertyGroup Label="Globals">
-    <ProjectGuid>{52AC08C0-396E-4F0B-8C3D-B97E6BDF5D1F}</ProjectGuid>
+    <ProjectGuid>{A16F9DCF-7F32-43AB-A044-74B7C660FC9B}</ProjectGuid>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
@@ -221,6 +221,7 @@
       <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</BrowseInformation>
       <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
     </ClCompile>
+    <ClCompile Include="cg_multiview.c" />
     <ClCompile Include="cg_newDraw.c">
       <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
       <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</BrowseInformation>
Index: cgame/cgame.vcxproj.filters
===================================================================
--- cgame/cgame.vcxproj.filters	(revision 304)
+++ cgame/cgame.vcxproj.filters	(working copy)
@@ -113,6 +113,9 @@
     <ClCompile Include="cg_http_cmds.c">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="cg_multiview.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\game\bg_local.h">
Index: game/bg_misc.c
===================================================================
--- game/bg_misc.c	(revision 315)
+++ game/bg_misc.c	(working copy)
@@ -4120,3 +4120,107 @@
 
 // consts to offset random reinforcement seeds
 const unsigned int aReinfSeeds[MAX_REINFSEEDS] = { 11, 3, 13, 7, 2, 5, 1, 17 };
+
+// strip colors and control codes, copying up to dwMaxLength-1 "good" chars and nul-terminating
+// returns the length of the cleaned string
+int BG_cleanName(const char *pszIn, char *pszOut, unsigned int dwMaxLength, qboolean fCRLF) {
+	const char *pInCopy = pszIn;
+	const char *pszOutStart = pszOut;
+
+	while (*pInCopy && (pszOut - pszOutStart < dwMaxLength - 1)) {
+		if (*pInCopy == '^') {
+			pInCopy += ((pInCopy[1] == 0) ? 1 : 2);
+		}
+		else if ((*pInCopy < 32 && (!fCRLF || *pInCopy != '\n')) || (*pInCopy > 126))    {
+			pInCopy++;
+		}
+		else {
+			*pszOut++ = *pInCopy++;
+		}
+	}
+
+	*pszOut = 0;
+	return(pszOut - pszOutStart);
+}
+
+// Multiview: Convert weaponstate to simpler format
+int BG_simpleWeaponState(int ws) {
+	switch (ws)
+	{
+	case WEAPON_READY:
+	case WEAPON_READYING:
+	case WEAPON_RELAXING:
+		return(WSTATE_IDLE);
+	case WEAPON_RAISING:
+	case WEAPON_DROPPING:
+		return(WSTATE_SWITCH);
+	case WEAPON_FIRING:
+	case WEAPON_FIRINGALT:
+		return(WSTATE_FIRE);
+	case WEAPON_RELOADING:
+		return(WSTATE_RELOAD);
+	}
+
+	return(WSTATE_IDLE);
+}
+
+const char* BG_ShortClassnameForNumber(int classNum) {
+	switch (classNum) {
+	case PC_SOLDIER:
+		return "Soldr";
+	case PC_MEDIC:
+		return "Medic";
+	case PC_ENGINEER:
+		return "Engr";
+	case PC_LT:
+		return "Leut";
+	default:
+		return "^1ERROR";
+	}
+}
+
+// Multiview: Expand the hints.  Because we map a couple hints
+// into a single value, we can't replicate the proper hint back
+// in all cases.
+int BG_simpleHintsExpand(int hint, int val) {
+	switch (hint) {
+	case 0: return((val >= 0) ? HINT_DISARM : 0);
+	case 1: return((val >= 0) ? HINT_BUILD : HINT_BREAKABLE);
+	case 2: return((val >= 0) ? HINT_BUILD : HINT_MG42);
+	case 3: return((val >= 0) ? HINT_BUILD : HINT_BREAKABLE_DYNAMITE);
+	}
+
+	return(0);
+}
+
+// Multiview: Reduce hint info to 2 bits.  However, we can really
+// have up to 8 values, as some hints will have a 0 value for
+// cursorHintVal
+int BG_simpleHintsCollapse(int hint, int val) {
+	switch (hint) {
+	case HINT_DISARM:
+		if (val > 0) {
+			return(0);
+		}
+	case HINT_BUILD:
+		if (val > 0) {
+			return(1);
+		}
+	case HINT_BREAKABLE:
+		if (val == 0) {
+			return(1);
+		}
+	case HINT_DOOR_ROTATING:
+	case HINT_BUTTON:
+	case HINT_MG42:
+		if (val == 0) {
+			return(2);
+		}
+	case HINT_BREAKABLE_DYNAMITE:
+		if (val == 0) {
+			return(3);
+		}
+	}
+
+	return(0);
+}
Index: game/bg_public.h
===================================================================
--- game/bg_public.h	(revision 324)
+++ game/bg_public.h	(working copy)
@@ -254,6 +254,14 @@
 	WEAPON_RELOADING	//----(SA)	added
 } weaponstate_t;
 
+// OSPx - MultiView
+typedef enum {
+	WSTATE_IDLE,
+	WSTATE_SWITCH,
+	WSTATE_FIRE,
+	WSTATE_RELOAD
+} weaponstateCompact_t;
+
 // pmove->pm_flags	(sent as max 16 bits in msg.c)
 #define	PMF_DUCKED			1
 #define	PMF_JUMP_HELD		2
@@ -455,8 +463,9 @@
 	PW_BALL,
 
 // OSPx	
-	PW_READY,			// Ready
-	PW_BLACKOUT = 14,	// Specklock
+	PW_READY,				// Ready
+	PW_BLACKOUT = 17,		// Specklock
+	PW_MVCLIENTLIST = 18,   // MV client info.. need a full 32 bits
 // -OSPx
 
 	PW_NUM_POWERUPS
@@ -1727,5 +1736,22 @@
 extern animStringItem_t animStateStr[];
 extern animStringItem_t animBodyPartsStr[];
 
-// L0 - Crosshairs
+// L0  
+
+// Crosshairs
 void BG_setCrosshair(char *colString, float *col, float alpha, char *cvarName);
+
+// Color escape handling
+int BG_cleanName(const char *pszIn, char *pszOut, unsigned int dwMaxLength, qboolean fCRLF);
+
+// Multiview 
+#define MAX_MVCLIENTS               32
+#define MV_SCOREUPDATE_INTERVAL     5000    // in msec
+
+const char* BG_ShortClassnameForNumber(int classNum);
+
+int BG_simpleHintsCollapse(int hint, int val);
+int BG_simpleHintsExpand(int hint, int val);
+int BG_simpleWeaponState(int ws);
+
+// ~L0
Index: game/g_active.c
===================================================================
--- game/g_active.c	(revision 322)
+++ game/g_active.c	(working copy)
@@ -423,19 +423,22 @@
 	client->oldwbuttons = client->wbuttons;
 	client->wbuttons = ucmd->wbuttons;
 
-	// attack button cycles through spectators
-	if ((client->buttons & BUTTON_ATTACK) && !(client->oldbuttons & BUTTON_ATTACK)) {
-		Cmd_FollowCycle_f(ent, 1);
+	// OSPx - MV clients use these buttons locally for other things
+	if (client->pers.mvCount < 1) {
+		// attack button cycles through spectators
+		if ((client->buttons & BUTTON_ATTACK) && !(client->oldbuttons & BUTTON_ATTACK)) {
+			Cmd_FollowCycle_f(ent, 1);
+		}
+		else if (
+			(client->sess.sessionTeam == TEAM_SPECTATOR) && // don't let dead team players do free fly
+			(client->sess.spectatorState == SPECTATOR_FOLLOW) &&
+			(client->buttons & BUTTON_ACTIVATE) &&
+			!(client->oldbuttons & BUTTON_ACTIVATE) &&
+			G_allowFollow(ent, TEAM_RED) && G_allowFollow(ent, TEAM_BLUE)) { // OSPx - Speclock
+			// code moved to StopFollowing
+			StopFollowing(ent);
+		}
 	}
-	else if (
-		(client->sess.sessionTeam == TEAM_SPECTATOR) && // don't let dead team players do free fly
-		(client->sess.spectatorState == SPECTATOR_FOLLOW) &&
-		(client->buttons & BUTTON_ACTIVATE) &&
-		!(client->oldbuttons & BUTTON_ACTIVATE) &&
-		G_allowFollow(ent, TEAM_RED) && G_allowFollow(ent, TEAM_BLUE)) { // OSPx - Speclock
-		// code moved to StopFollowing
-		StopFollowing(ent);
-	}
 }
 
 
@@ -998,11 +1001,13 @@
 		return;
 	}
 
+	/*
 	if (client->cameraPortal) {
 		G_SetOrigin( client->cameraPortal, client->ps.origin );
 		trap_LinkEntity(client->cameraPortal);
 		VectorCopy( client->cameraOrigin, client->cameraPortal->s.origin2);
 	}
+	*/
 
 	// L0 - LT info
 	if ( g_LTinfoMsg.integer && 
@@ -1073,6 +1078,13 @@
 		//	return;
 	}
 
+	// OSPx - Multiview
+	if (client->wantsscore) {
+		//G_SendScore(ent);
+		DeathmatchScoreboardMessage(ent);
+		client->wantsscore = qfalse;
+	}
+
 	//
 	// check for exiting intermission
 	//
@@ -1090,9 +1102,11 @@
 	// spectators don't do much
 	// DHM - Nerve :: In limbo use SpectatorThink
 	if ( client->sess.sessionTeam == TEAM_SPECTATOR || client->ps.pm_flags & PMF_LIMBO ) {
+		/*
 		if ( client->sess.spectatorState == SPECTATOR_SCOREBOARD ) {
 			return;
 		}
+		*/
 		SpectatorThink( ent, ucmd );
 		return;
 	}
@@ -1198,7 +1212,7 @@
 	// L0 - Admin bot, ping fluxation
 	SB_maxPingFlux(client);
 										  // OSPx - Pause
-	if (reloading || client->cameraPortal || level.match_pause != PAUSE_NONE) {
+	if (reloading || client->ps.eFlags & EF_VIEWING_CAMERA || level.match_pause != PAUSE_NONE) {
 		ucmd->buttons = 0;
 		ucmd->forwardmove = 0;
 		ucmd->rightmove = 0;
@@ -1211,7 +1225,7 @@
 		{
 			client->ps.pm_type = PM_FREEZE;
 		} // -OSPx
-		if (client->cameraPortal) {
+		if (client->ps.eFlags & EF_VIEWING_CAMERA) {
 			VectorClear(client->ps.velocity);
 			client->ps.pm_type = PM_FREEZE;
 		}
@@ -1657,9 +1671,9 @@
 
 ==================
 */
-void SpectatorClientEndFrame( gentity_t *ent ) {
+void SpectatorClientEndFrame(gentity_t *ent) {
 	gclient_t	*cl;
-	int do_respawn=0; // JPW NERVE
+	int do_respawn = 0; // JPW NERVE
 	int	savedScore;		// DHM - Nerve
 	int savedRespawns;	// DHM - Nerve
 	int savedClass;		// NERVE - SMF
@@ -1666,8 +1680,15 @@
 	int flags;
 	int testtime;
 
+	// OSPx - specs periodically get score updates for useful demo playback info
+	if ( /*ent->client->pers.mvCount > 0 &&*/ ent->client->pers.mvScoreUpdate < level.time) {
+		ent->client->pers.mvScoreUpdate = level.time + MV_SCOREUPDATE_INTERVAL;
+		ent->client->wantsscore = qtrue;
+		//		G_SendScore(ent);
+	}
+
 	// if we are doing a chase cam or a remote view, grab the latest info
-	if (( ent->client->sess.spectatorState == SPECTATOR_FOLLOW ) || (ent->client->ps.pm_flags & PMF_LIMBO)) { // JPW NERVE for limbo
+	if ((ent->client->sess.spectatorState == SPECTATOR_FOLLOW) || (ent->client->ps.pm_flags & PMF_LIMBO)) { // JPW NERVE for limbo
 		int		clientNum;
 
 		if (ent->client->sess.sessionTeam == TEAM_RED) {
@@ -1675,8 +1696,8 @@
 			testtime = teamRespawnTime(TEAM_RED, qfalse);
 
 			// L0 - If warmup damage is on, respawn instantly
-			if ( g_warmupDamage.integer ) {
-				if ( g_gamestate.integer != GS_PLAYING ) {
+			if (g_warmupDamage.integer) {
+				if (g_gamestate.integer != GS_PLAYING) {
 					testtime = teamRespawnTime(TEAM_RED, qtrue);
 					do_respawn = 1;
 				}
@@ -1683,7 +1704,7 @@
 			} // End
 
 			if (testtime < ent->client->pers.lastReinforceTime)
-				do_respawn=1;
+				do_respawn = 1;
 
 			ent->client->pers.lastReinforceTime = testtime;
 		}
@@ -1692,8 +1713,8 @@
 			testtime = teamRespawnTime(TEAM_BLUE, qfalse);
 
 			// L0 - If warmup damage is on, respawn instantly
-			if ( g_warmupDamage.integer ) {
-				if ( g_gamestate.integer != GS_PLAYING ) {
+			if (g_warmupDamage.integer) {
+				if (g_gamestate.integer != GS_PLAYING) {
 					testtime = teamRespawnTime(TEAM_BLUE, qtrue);
 					do_respawn = 1;
 				}
@@ -1700,39 +1721,47 @@
 			} // End
 
 			if (testtime < ent->client->pers.lastReinforceTime)
-				do_respawn=1;
+				do_respawn = 1;
 
 			ent->client->pers.lastReinforceTime = testtime;
 		}
 
-		if ( ( g_maxlives.integer > 0 || g_alliedmaxlives.integer > 0 || g_axismaxlives.integer > 0 ) && ent->client->ps.persistant[PERS_RESPAWNS_LEFT] == 0 ) {
+		if ((g_maxlives.integer > 0 || g_alliedmaxlives.integer > 0 || g_axismaxlives.integer > 0) && ent->client->ps.persistant[PERS_RESPAWNS_LEFT] == 0) {
 			do_respawn = 0;
 		}
 
-		if ( do_respawn ) {
+		if (do_respawn) {
 			reinforce(ent);
 			return;
 		}
 
+		// OSPx - Multiview - Limbos aren't following while in MV
+		if ((ent->client->ps.pm_flags & PMF_LIMBO) && ent->client->pers.mvCount > 0) {
+			return;
+		}
+
 		clientNum = ent->client->sess.spectatorClient;
 
 		// team follow1 and team follow2 go to whatever clients are playing
-		if ( clientNum == -1 ) {
+		if (clientNum == -1) {
 			clientNum = level.follow1;
-		} else if ( clientNum == -2 ) {
+		}
+		else if (clientNum == -2) {
 			clientNum = level.follow2;
 		}
-		if ( clientNum >= 0 ) {
-			cl = &level.clients[ clientNum ];
-			if ( cl->pers.connected == CON_CONNECTED && cl->sess.sessionTeam != TEAM_SPECTATOR ) {
+		if (clientNum >= 0) {
+			cl = &level.clients[clientNum];
+			if (cl->pers.connected == CON_CONNECTED && cl->sess.sessionTeam != TEAM_SPECTATOR) {
 				// L0 - Ping and Score fix (solves issue with \serverstatus showing who's spectating who)
-				int ping = ent->client->ps.ping; 
+				int ping = ent->client->ps.ping;
 				int score = ent->client->ps.persistant[PERS_SCORE];
 				// DHM - Nerve :: carry flags over
-				flags = (cl->ps.eFlags & ~(EF_VOTED)) | (ent->client->ps.eFlags & (EF_VOTED));				
+				flags = (cl->ps.eFlags & ~(EF_VOTED)) | (ent->client->ps.eFlags & (EF_VOTED));
 
 				// JPW NERVE -- limbo latch
 				if (ent->client->sess.sessionTeam != TEAM_SPECTATOR && ent->client->ps.pm_flags & PMF_LIMBO) {
+					int savedMVList = ent->client->ps.powerups[PW_MVCLIENTLIST]; // OSPx - Multiview
+
 					// abuse do_respawn var
 					savedScore = ent->client->ps.persistant[PERS_SCORE];
 					do_respawn = ent->client->ps.pm_time;
@@ -1743,9 +1772,10 @@
 					ent->client->ps.pm_flags |= PMF_FOLLOW;
 					ent->client->ps.pm_flags |= PMF_LIMBO;
 
-					ent->client->ps.persistant[PERS_RESPAWNS_LEFT] = savedRespawns;	
+					ent->client->ps.persistant[PERS_RESPAWNS_LEFT] = savedRespawns;
 					ent->client->ps.pm_time = do_respawn;							// put pm_time back
 					ent->client->ps.persistant[PERS_SCORE] = savedScore;			// put score back
+					ent->client->ps.powerups[PW_MVCLIENTLIST] = savedMVList;		// OSPx - MultiView
 					ent->client->ps.stats[STAT_PLAYER_CLASS] = savedClass;			// NERVE - SMF - put player class back
 				}
 				else {
@@ -1756,28 +1786,35 @@
 				// DHM - Nerve :: carry flags over
 				ent->client->ps.eFlags = flags;
 				// L0 - Ping & Score fix
-				ent->client->ps.ping = ping; 
+				ent->client->ps.ping = ping;
 				ent->client->ps.persistant[PERS_SCORE] = score;
 				return;
-			} else {
+			}
+			else {
 				// drop them to free spectators unless they are dedicated camera followers
-				if ( ent->client->sess.spectatorClient >= 0 ) {
+				if (ent->client->sess.spectatorClient >= 0) {
 					ent->client->sess.spectatorState = SPECTATOR_FREE;
-					ClientBegin( ent->client - level.clients );
+					ClientBegin(ent->client - level.clients);
 				}
 			}
 		}
 	}
 
-	if ( ent->client->sess.spectatorState == SPECTATOR_SCOREBOARD ) {
+	if (ent->client->sess.spectatorState == SPECTATOR_SCOREBOARD) {
 		ent->client->ps.pm_flags |= PMF_SCOREBOARD;
-	} else {
+	}
+	else {
 		ent->client->ps.pm_flags &= ~PMF_SCOREBOARD;
 	}
 
-	// OSPx - Speclock
-	ent->client->ps.powerups[PW_BLACKOUT] = (G_blockoutTeam(ent, TEAM_RED) * TEAM_RED) |
-											(G_blockoutTeam(ent, TEAM_BLUE) * TEAM_BLUE);
+	// OSPx - Speclock & MultiView
+	// we are at a free-floating spec state for a player,
+	// set speclock status, as appropriate
+	//	 --> Can we use something besides a powerup slot?
+	if (ent->client->pers.mvCount < 1) {
+		ent->client->ps.powerups[PW_BLACKOUT] = (G_blockoutTeam(ent, TEAM_RED) * TEAM_RED) |
+												(G_blockoutTeam(ent, TEAM_BLUE) * TEAM_BLUE);
+	}
 }
 
 
Index: game/g_client.c
===================================================================
--- game/g_client.c	(revision 322)
+++ game/g_client.c	(working copy)
@@ -507,6 +507,13 @@
 		G_Printf("player already deployed, skipping\n");
 		return;
 	}
+
+	// OSPx - multiview
+	if (ent->client->pers.mvCount > 0) {
+		G_smvRemoveInvalidClients(ent, TEAM_RED);
+		G_smvRemoveInvalidClients(ent, TEAM_BLUE);
+	}
+
 	// get team to deploy from passed entity
 
 	// DHM - Nerve :: restore persistant data now that we're out of Limbo
@@ -2109,6 +2116,9 @@
 
 	// count current clients and rank for scoreboard
 	CalculateRanks();
+
+	// OSPx - Multiview
+	G_smvUpdateClientCSList(ent);
 }
 
 /*
@@ -2576,6 +2586,9 @@
 	if ( ent->r.svFlags & SVF_BOT ) {
 		BotAIShutdownClient( clientNum );
 	}
+
+	// OSPx - Multiview
+	G_smvAllRemoveSingleClient(ent - g_entities);
 }
 
 
Index: game/g_cmds.c
===================================================================
--- game/g_cmds.c	(revision 324)
+++ game/g_cmds.c	(working copy)
@@ -33,7 +33,7 @@
 		cl = &level.clients[level.sortedClients[i]];
 
 		// NERVE - SMF - if on same team, send across player class
-		if ( cl->ps.persistant[PERS_TEAM] == ent->client->ps.persistant[PERS_TEAM] )
+		if (cl->ps.persistant[PERS_TEAM] == ent->client->ps.persistant[PERS_TEAM] || G_smvLocateEntityInMVList(ent, level.sortedClients[i], qfalse))
 			playerClass = cl->ps.stats[STAT_PLAYER_CLASS];
 		else
 			playerClass = 0;
@@ -72,7 +72,8 @@
 ==================
 */
 void Cmd_Score_f( gentity_t *ent ) {
-	DeathmatchScoreboardMessage( ent );
+	//DeathmatchScoreboardMessage( ent );
+	ent->client->wantsscore = qtrue; // OSPx - Patched for multiview
 }
 
 /*
@@ -726,9 +727,16 @@
 	//
 
 	// DHM - Nerve
-	if ( client->pers.initialSpawn && team != TEAM_SPECTATOR )
+	if (client->pers.initialSpawn && team != TEAM_SPECTATOR) {
 		client->pers.initialSpawn = qfalse;
 
+		// OSPx - no MV in-game
+		if (client->pers.mvCount > 0) {
+			G_smvRemoveInvalidClients(ent, TEAM_RED);
+			G_smvRemoveInvalidClients(ent, TEAM_BLUE);
+		}
+	}
+
 	// he starts at 'base'
 	client->pers.teamState.state = TEAM_BEGIN;
 	if ( oldTeam != TEAM_SPECTATOR ) {
@@ -756,6 +764,11 @@
 	// they go to the end of the line for tournements
 	if ( team == TEAM_SPECTATOR ) {
 		client->sess.spectatorTime = level.time;
+
+		// OSPx - Multiview
+		if (team != oldTeam) {
+			G_smvAllRemoveSingleClient(ent - g_entities);
+		}
 	}
 
 	client->sess.specLocked = 0;	// L0 - Speclocked
@@ -2349,15 +2362,29 @@
 */
 void Cmd_StartCamera_f( gentity_t *ent ) {
 
-	if ( !CheatsOk( ent ) ) {
-		return;
+	if (ent->client->cameraPortal) {
+		G_FreeEntity(ent->client->cameraPortal);
 	}
+	ent->client->cameraPortal = G_Spawn();
 
-	g_camEnt->r.svFlags |= SVF_PORTAL;
-	g_camEnt->r.svFlags &= ~SVF_NOCLIENT;
-	ent->client->cameraPortal = g_camEnt;
+	ent->client->cameraPortal->s.eType = ET_CAMERA;
+	ent->client->cameraPortal->s.apos.trType = TR_STATIONARY;
+	ent->client->cameraPortal->s.apos.trTime = 0;
+	ent->client->cameraPortal->s.apos.trDuration = 0;
+	VectorClear(ent->client->cameraPortal->s.angles);
+	VectorClear(ent->client->cameraPortal->s.apos.trDelta);
+	G_SetOrigin(ent->client->cameraPortal, ent->r.currentOrigin);
+	VectorCopy(ent->r.currentOrigin, ent->client->cameraPortal->s.origin2);
+
+	ent->client->cameraPortal->s.frame = 0;
+
+	ent->client->cameraPortal->r.svFlags |= (SVF_PORTAL | SVF_SINGLECLIENT);
+	ent->client->cameraPortal->r.singleClient = ent->client->ps.clientNum;
+
 	ent->client->ps.eFlags |= EF_VIEWING_CAMERA;
 	ent->s.eFlags |= EF_VIEWING_CAMERA;
+
+	VectorCopy(ent->r.currentOrigin, ent->client->cameraOrigin);  // backup our origin
 }
 
 /*
@@ -2367,18 +2394,33 @@
 */
 void Cmd_StopCamera_f( gentity_t *ent ) {
 
-	if ( !CheatsOk( ent ) ) {
-		return;
-	}
+	if (ent->client->cameraPortal && (ent->client->ps.eFlags & EF_VIEWING_CAMERA)) {
+		// send a script event
+		//		G_Script_ScriptEvent( ent->client->cameraPortal, "stopcam", "" );
 
-	if (ent->client->cameraPortal) {
-		// send a script event
-		G_Script_ScriptEvent( ent->client->cameraPortal, "stopcam", "" );
 		// go back into noclient mode
-		ent->client->cameraPortal->r.svFlags |= SVF_NOCLIENT;
+		G_FreeEntity(ent->client->cameraPortal);
 		ent->client->cameraPortal = NULL;
+
 		ent->s.eFlags &= ~EF_VIEWING_CAMERA;
 		ent->client->ps.eFlags &= ~EF_VIEWING_CAMERA;
+
+		//G_SetOrigin( ent, ent->client->cameraOrigin );	// restore our origin
+		//VectorCopy( ent->client->cameraOrigin, ent->client->ps.origin );
+
+		// (SA) trying this in client to avoid 1 frame of player drawing
+		//		ent->s.eFlags &= ~EF_NODRAW;
+		//		ent->client->ps.eFlags &= ~EF_NODRAW;
+
+		// RF, if we are near the spawn point, save the "current" game, for reloading after death
+		//		sp = NULL;
+		// gcc: suggests () around assignment used as truth value
+		//		while ((sp = G_Find( sp, FOFS(classname), "info_player_deathmatch" ))) {	// info_player_start becomes info_player_deathmatch in it's spawn functon
+		//			if (Distance( ent->s.pos.trBase, sp->s.origin ) < 256 && trap_InPVS( ent->s.pos.trBase, sp->s.origin )) {
+		//				G_SaveGame( NULL );
+		//				break;
+		//			}
+		//		}
 	}
 }
 
@@ -2388,18 +2430,26 @@
 =================
 */
 void Cmd_SetCameraOrigin_f( gentity_t *ent ) {
-	char		buffer[MAX_TOKEN_CHARS];
+	char buffer[MAX_TOKEN_CHARS];
 	int i;
+	vec3_t origin;
 
-	if ( trap_Argc() != 4 ) {
+	if (trap_Argc() != 4) {
 		return;
 	}
 
-	VectorClear( ent->client->cameraOrigin );
-	for ( i = 0 ; i < 3 ; i++ ) {
-		trap_Argv( i + 1, buffer, sizeof( buffer ) );
-		ent->client->cameraOrigin[i] = atof( buffer );
+	for (i = 0; i < 3; i++) {
+		trap_Argv(i + 1, buffer, sizeof(buffer));
+		origin[i] = atof(buffer);
 	}
+
+	if (ent->client->cameraPortal) {
+		//G_SetOrigin( ent->client->cameraPortal, origin );	// set our origin
+		VectorCopy(origin, ent->client->cameraPortal->s.origin2);
+		trap_LinkEntity(ent->client->cameraPortal);
+		//	G_SetOrigin( ent, origin );	// set our origin
+		//	VectorCopy( origin, ent->client->ps.origin );
+	}
 }
 
 
@@ -3205,6 +3255,29 @@
 		Cmd_ready(ent, qfalse);
 	else if (Q_stricmp(cmd, "readyteam") == 0)
 		Cmd_teamReady(ent, qtrue);
+
+	else if(!Q_stricmp(cmd, "mvadd")) {
+		G_smvAdd_cmd(ent);
+	}
+	else if (!Q_stricmp(cmd, "mvdel"))    {
+		G_smvDel_cmd(ent);
+	}
+	else if (!Q_stricmp(cmd, "mvallies"))                                                                   {
+		G_smvAddTeam_cmd(ent, TEAM_BLUE);
+	}
+	else if (!Q_stricmp(cmd, "mvaxis"))                                                                                                                                                      {
+		G_smvAddTeam_cmd(ent, TEAM_RED);
+	}
+	else if (!Q_stricmp(cmd, "mvall"))                                                                                                                                                                                                                                     {
+		G_smvAddTeam_cmd(ent, TEAM_BLUE);
+		G_smvAddTeam_cmd(ent, TEAM_RED);
+	}
+	else if (!Q_stricmp(cmd, "mvnone")) {
+		if (ent->client->pers.mvCount > 0) {
+			G_smvRemoveInvalidClients(ent, TEAM_RED);
+			G_smvRemoveInvalidClients(ent, TEAM_BLUE);
+		}
+	}
 // End
 	else if (Q_stricmp (cmd, "levelshot") == 0)
 		Cmd_LevelShot_f (ent);
Index: game/g_local.h
===================================================================
--- game/g_local.h	(revision 324)
+++ game/g_local.h	(working copy)
@@ -493,6 +493,14 @@
 #define PICKUP_TOUCH	1	// pickup items when touched
 #define PICKUP_FORCE	2	// pickup the next item when touched (and reset to PICKUP_ACTIVATE when done)
 
+// OSPx -- multiview handling
+#define MULTIVIEW_MAXVIEWS  16
+typedef struct {
+	qboolean fActive;
+	int entID;
+	gentity_t   *camera;
+} mview_t;
+
 // client data that stays across multiple respawns, but is cleared
 // on each level change or team change at ClientBegin()
 typedef struct {
@@ -582,6 +590,12 @@
 
 	// Debounce commands (mainly ones that are not cheap to call..)
 	int cmd_debounce;
+
+	// Multiview
+	mview_t mv[MULTIVIEW_MAXVIEWS];		// Multiview portals
+	int mvCount;                        // Number of active portals
+	int mvReferenceList;                // Reference list used to generate views after a map_restart
+	int mvScoreUpdate;                  // Period to send score info to MV clients
 // ~L0
 } clientPersistant_t;
 
@@ -716,6 +730,9 @@
 	int cmdcount;							// antiwarp command queue # valid commands
 	float cmddelta;							// antiwarp command queue # valid commands
 	usercmd_t cmds[LAG_MAX_COMMANDS];       // antiwarp command queue
+
+	// MultiView
+	qboolean wantsscore;
 	// End
 };
 
@@ -914,7 +931,8 @@
 // OSPx - Pause 
 typedef enum {
 	DP_PAUSEINFO,
-	DP_UNPAUSING
+	DP_UNPAUSING,
+	DP_MVSPAWN          // Set up MV views for clients who need them
 } enum_t_dp;
 
 // OSPx - Team extras
@@ -1192,6 +1210,7 @@
 void ClientThink( int clientNum );
 void ClientEndFrame( gentity_t *ent );
 void G_RunClient( gentity_t *ent );
+void limbo(gentity_t *ent, qboolean makeCorpse);
 
 //
 // g_team.c
@@ -1213,6 +1232,7 @@
 qboolean G_playersReady(void);
 void G_readyReset(qboolean aForced);
 void G_readyStart(void);
+int G_teamID(gentity_t *ent);
 //~ L0
 
 //
@@ -1990,6 +2010,24 @@
 extern GeoIP * gidb;
 void G_ReadIP(gclient_t *client);
 
+//
+// g_multiview.c
+//
+//qboolean G_smvCommands(gentity_t *ent, char *cmd);
+void G_smvAdd_cmd(gentity_t *ent);
+void G_smvAddTeam_cmd(gentity_t *ent, int nTeam);
+void G_smvDel_cmd(gentity_t *ent);
+//
+void G_smvAddView(gentity_t *ent, int pID);
+void G_smvAllRemoveSingleClient(int pID);
+unsigned int G_smvGenerateClientList(gentity_t *ent);
+qboolean G_smvLocateEntityInMVList(gentity_t *ent, int pID, qboolean fRemove);
+void G_smvRegenerateClients(gentity_t *ent, int clientList);
+void G_smvRemoveEntityInMVList(gentity_t *ent, mview_t *ref);
+void G_smvRemoveInvalidClients(gentity_t *ent, int nTeam);
+qboolean G_smvRunCamera(gentity_t *ent);
+void G_smvUpdateClientCSList(gentity_t *ent);
+
 //
 // Logs
 //
Index: game/g_main.c
===================================================================
--- game/g_main.c	(revision 324)
+++ game/g_main.c	(working copy)
@@ -1723,6 +1723,10 @@
 	// L0 - Create round Token
 	if (g_gamestate.integer == GS_PLAYING)		
 		globalStats_roundToken();
+
+	// OSPx - Reinstate any MV views for clients -- need to do this after all init is complete
+	// --- maybe not the best place to do this... seems to be some race conditions on map_restart
+	G_spawnPrintf(DP_MVSPAWN, level.time + 2000, NULL);
 }
 
 /*
@@ -2097,7 +2101,8 @@
 
 	// if we are at the intermission, send the new info to everyone
 	if ( level.intermissiontime ) {
-		SendScoreboardMessageToAllClients();
+		//SendScoreboardMessageToAllClients();
+		level.clients[level.sortedClients[i]].wantsscore = qtrue; // OSPx - Patched for multiview
 	}
 }
 
@@ -3461,7 +3466,8 @@
 			|| ent->s.eType == ET_FIRE_COLUMN
 			|| ent->s.eType == ET_FIRE_COLUMN_SMOKE
 			|| ent->s.eType == ET_EXPLO_PART
-			|| ent->s.eType == ET_RAMJET) {
+			|| ent->s.eType == ET_RAMJET) 
+		{
 			// OSPx - pausing
 			if (level.match_pause == PAUSE_NONE) {
 				G_RunMissile(ent);
@@ -3508,6 +3514,11 @@
 			continue;
 		}
 
+		// OSPx - multiview
+		if (ent->s.eType == ET_PORTAL && G_smvRunCamera(ent)) {
+			continue;
+		}
+
 		G_RunThink( ent );
 	}
 //end = trap_Milliseconds();
Index: game/g_match.c
===================================================================
--- game/g_match.c	(revision 320)
+++ game/g_match.c	(working copy)
@@ -857,6 +857,27 @@
 		}
 		break;
 	}
+
+	case DP_MVSPAWN:
+	{
+		int i;
+		gentity_t *ent;
+
+		for (i = 0; i < level.numConnectedClients; i++) {
+			ent = g_entities + level.sortedClients[i];
+
+			if (ent->client->pers.mvReferenceList == 0) {
+				continue;
+			}
+			if (ent->client->sess.sessionTeam != TEAM_SPECTATOR) {
+				continue;
+			}
+			G_smvRegenerateClients(ent, ent->client->pers.mvReferenceList);
+		}
+
+		break;
+	}
+
 	default:
 		break;
 	}
Index: game/g_multiview.c
===================================================================
--- game/g_multiview.c	(revision 0)
+++ game/g_multiview.c	(working copy)
@@ -0,0 +1,372 @@
+/*
+===========================================================================
+
+Wolfenstein: Enemy Territory GPL Source Code
+Copyright (C) 1999-2010 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Wolfenstein: Enemy Territory GPL Source Code (Wolf ET Source Code).  
+
+Wolf ET Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Wolf ET Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Wolf ET Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Wolf: ET Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Wolf ET Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+// g_multiview.c: Multiview handling
+// ---------------------------------
+//
+#include "g_local.h"
+
+/*
+	Extracted and moved to g_cmds
+
+qboolean G_smvCommands( gentity_t *ent, char *cmd ) {
+	if ( !Q_stricmp( cmd, "mvadd" ) ) {
+		G_smvAdd_cmd( ent );
+	} else if ( !Q_stricmp( cmd, "mvdel" ) )    {
+		G_smvDel_cmd( ent );
+	} else if ( !Q_stricmp( cmd, "mvallies" ) )                                                                   {
+		G_smvAddTeam_cmd( ent, TEAM_BLUE );
+	} else if ( !Q_stricmp( cmd, "mvaxis" ) )                                                                                                                                                      {
+		G_smvAddTeam_cmd( ent, TEAM_RED );
+	} else if ( !Q_stricmp( cmd, "mvall" ) )                                                                                                                                                                                                                                     {
+		G_smvAddTeam_cmd( ent, TEAM_BLUE );
+		G_smvAddTeam_cmd( ent, TEAM_RED );
+	} else if ( !Q_stricmp( cmd, "mvnone" ) ) {
+		if ( ent->client->pers.mvCount > 0 ) {
+			G_smvRemoveInvalidClients( ent, TEAM_RED );
+			G_smvRemoveInvalidClients( ent, TEAM_BLUE );
+		}
+	} else {
+		return( qfalse );
+	}
+
+	return( qtrue );
+}
+*/
+
+
+void G_smvAdd_cmd( gentity_t *ent ) {
+	int pID;
+	char str[MAX_TOKEN_CHARS];
+
+
+	// Clients will always send pIDs
+	trap_Argv( 1, str, sizeof( str ) );
+	pID = atoi( str );
+	if ( pID < 0 || pID > level.maxclients || g_entities[pID].client->pers.connected != CON_CONNECTED ) {
+		CP( va( "print \"[lof]** [lon]Client[lof] %d [lon]is not connected[lof]!\n\"", pID ) );
+		return;
+	}
+
+	if ( g_entities[pID].client->sess.sessionTeam == TEAM_SPECTATOR ) {
+		CP( va( "print \"[lof]** [lon]Client[lof] %s^7 [lon]is not in the game[lof]!\n\"", level.clients[pID].pers.netname ) );
+		return;
+	}
+
+	if ( !G_allowFollow( ent, G_teamID( &g_entities[pID] ) ) ) {
+		CP( va( "print \"[lof]** [lon]The %s team is locked from spectators[lof]!\n\"", aTeams[G_teamID( &g_entities[pID] )] ) );
+		return;
+	}
+
+	G_smvAddView( ent, pID );
+}
+
+
+void G_smvAddTeam_cmd( gentity_t *ent, int nTeam ) {
+	int i, pID;
+
+	if ( !G_allowFollow( ent, nTeam ) ) {
+		CP( va( "print \"[lof]** [lon]The %s team is locked from spectators[lof]!\n\"", aTeams[nTeam] ) );
+		return;
+	}
+
+	// For limbo'd MV action
+	if ( ent->client->sess.sessionTeam != TEAM_SPECTATOR &&
+		 ( !( ent->client->ps.pm_flags & PMF_LIMBO ) || ent->client->sess.sessionTeam != nTeam ) ) {
+		return;
+	}
+
+	for ( i = 0; i < level.numPlayingClients; i++ ) {
+		pID = level.sortedClients[i];
+		if ( g_entities[pID].client->sess.sessionTeam == nTeam && ent != &g_entities[pID] ) {
+			G_smvAddView( ent, pID );
+		}
+	}
+}
+
+
+void G_smvDel_cmd( gentity_t *ent ) {
+	int pID;
+	char str[MAX_TOKEN_CHARS];
+
+	// Clients will always send pIDs
+	trap_Argv( 1, str, sizeof( str ) );
+	pID = atoi( str );
+	if ( !G_smvLocateEntityInMVList( ent, pID, qtrue ) ) {
+		CP( va( "print \"[lof]** [lon]Client[lof] %s^7 [lon]is not currently viewed[lof]!\n\"", level.clients[pID].pers.netname ) );
+	}
+}
+
+
+// Add a player entity to another player's multiview list
+void G_smvAddView( gentity_t *ent, int pID ) {
+	int i;
+	mview_t *mv = NULL;
+	gentity_t *v;
+
+	if ( pID >= MAX_MVCLIENTS || G_smvLocateEntityInMVList( ent, pID, qfalse ) ) {
+		return;
+	}
+
+	for ( i = 0; i < MULTIVIEW_MAXVIEWS; i++ ) {
+		if ( !ent->client->pers.mv[i].fActive ) {
+			mv = &ent->client->pers.mv[i];
+			break;
+		}
+	}
+
+	if ( mv == NULL ) {
+		CP( va( "print \"[lof]** [lon]Sorry, no more MV slots available (all[lof] %d [lon]in use)[lof]\n\"", MULTIVIEW_MAXVIEWS ) );
+		return;
+	}
+
+	mv->camera = G_Spawn();
+	if ( mv->camera == NULL ) {
+		return;
+	}
+
+	if ( ent->client->sess.sessionTeam == TEAM_SPECTATOR && /*ent->client->sess.sessionTeam != TEAM_SPECTATOR ||*/
+		 ent->client->sess.spectatorState == SPECTATOR_FOLLOW ) {
+		SetTeam( ent, "s", qtrue );
+	} else if ( ent->client->sess.sessionTeam != TEAM_SPECTATOR && !( ent->client->ps.pm_flags & PMF_LIMBO ) ) {
+		limbo( ent, qtrue );
+	}
+
+	ent->client->ps.clientNum = ent - g_entities;
+	ent->client->sess.spectatorState = SPECTATOR_FREE;
+
+	ent->client->pers.mvCount++;
+	mv->fActive = qtrue;
+	mv->entID = pID;
+
+	v = mv->camera;
+	v->classname = "misc_portal_surface";
+	v->r.svFlags = SVF_PORTAL | SVF_SINGLECLIENT;   // Only merge snapshots for the target client
+	v->r.singleClient = ent->s.number;
+	v->s.eType = ET_PORTAL;
+
+	VectorClear( v->r.mins );
+	VectorClear( v->r.maxs );
+	trap_LinkEntity( v );
+
+	v->target_ent = &g_entities[pID];
+	v->TargetFlag = pID;
+	v->tagParent = ent;
+
+	G_smvUpdateClientCSList( ent );
+}
+
+
+// Find, and optionally delete an entity in a player's MV list
+qboolean G_smvLocateEntityInMVList( gentity_t *ent, int pID, qboolean fRemove ) {
+	int i;
+
+	if ( ent->client->pers.mvCount > 0 ) {
+		for ( i = 0; i < MULTIVIEW_MAXVIEWS; i++ ) {
+			if ( ent->client->pers.mv[i].fActive && ent->client->pers.mv[i].entID == pID ) {
+				if ( fRemove ) {
+					G_smvRemoveEntityInMVList( ent, &ent->client->pers.mv[i] );
+				}
+				return( qtrue );
+			}
+		}
+	}
+
+	return( qfalse );
+}
+
+
+// Explicitly shutdown a camera and update global list
+void G_smvRemoveEntityInMVList( gentity_t *ent, mview_t *ref ) {
+	ref->entID = -1;
+	ref->fActive = qfalse;
+	G_FreeEntity( ref->camera );
+	ref->camera = NULL;
+	ent->client->pers.mvCount--;
+
+	G_smvUpdateClientCSList( ent );
+}
+
+
+// Calculates a given client's MV player list
+unsigned int G_smvGenerateClientList( gentity_t *ent ) {
+	unsigned int i, mClients = 0;
+
+	for ( i = 0; i < MULTIVIEW_MAXVIEWS; i++ ) {
+		if ( ent->client->pers.mv[i].fActive ) {
+			mClients |= 1 << ent->client->pers.mv[i].entID;
+		}
+	}
+
+	return( mClients );
+}
+
+
+// Calculates a given client's MV player list
+void G_smvRegenerateClients( gentity_t *ent, int clientList ) {
+	int i;
+
+	for ( i = 0; i < MAX_MVCLIENTS; i++ ) {
+		if ( clientList & ( 1 << i ) ) {
+			G_smvAddView( ent, i );
+		}
+	}
+}
+
+
+// Update global MV list for a given client
+void G_smvUpdateClientCSList( gentity_t *ent ) {
+	ent->client->ps.powerups[PW_MVCLIENTLIST] = G_smvGenerateClientList( ent );
+}
+
+
+// Remove all clients from a team we can't watch (due to updated speclock)
+// or if the viewer enters the game
+void G_smvRemoveInvalidClients( gentity_t *ent, int nTeam ) {
+	int i, id;
+
+	for ( i = 0; i < level.numConnectedClients; i++ ) {
+		id = level.sortedClients[i];
+
+		if ( level.clients[id].sess.sessionTeam == TEAM_SPECTATOR ) {
+			continue;
+		}
+		if ( level.clients[id].sess.sessionTeam != nTeam && ent->client->sess.sessionTeam == TEAM_SPECTATOR ) {
+			continue;
+		}
+
+		G_smvLocateEntityInMVList( ent, id, qtrue );
+	}
+}
+
+// Scan all MV lists for a single client to remove
+void G_smvAllRemoveSingleClient( int pID ) {
+	int i;
+	gentity_t *ent;
+
+	for ( i = 0; i < level.numConnectedClients; i++ ) {
+		ent = g_entities + level.sortedClients[i];
+
+		if ( ent->client->pers.mvCount < 1 ) {
+			continue;
+		}
+		G_smvLocateEntityInMVList( ent, pID, qtrue );
+	}
+}
+
+
+// Set up snapshot merge based on this portal
+qboolean G_smvRunCamera( gentity_t *ent ) {
+	int id = ent->TargetFlag;
+	int chargeTime, sprintTime, hintTime, weapHeat;
+	playerState_t *tps, *ps;
+
+	// Opt out if not a real MV portal
+	if ( ent->tagParent == NULL || ent->tagParent->client == NULL ) {
+		return( qfalse );
+	}
+
+	if ( ( ps = &ent->tagParent->client->ps ) == NULL ) {
+		return( qfalse );
+	}
+
+	// If viewing client is no longer connected, delete this camera
+	if ( ent->tagParent->client->pers.connected != CON_CONNECTED ) {
+		G_FreeEntity( ent );
+		return( qtrue );
+	}
+
+	// Also remove if the target player is no longer in the game playing
+	if ( ent->target_ent->client->pers.connected != CON_CONNECTED ||
+		 ent->target_ent->client->sess.sessionTeam == TEAM_SPECTATOR ) {
+		G_smvLocateEntityInMVList( ent->tagParent, ent->target_ent - g_entities, qtrue );
+		return( qtrue );
+	}
+
+	// Seems that depending on player's state, we pull from either r.currentOrigin, or s.origin
+	//		if(!spec) then use: r.currentOrigin
+	//		if(spec) then use:  s.origin
+	//
+	// This is true for both the portal origin and its target (origin2)
+	//
+	VectorCopy( ent->tagParent->s.origin, ent->s.origin );
+	G_SetOrigin( ent, ent->s.origin );
+	VectorCopy( ent->target_ent->r.currentOrigin, ent->s.origin2 );
+	trap_LinkEntity( ent );
+
+	// Only allow client ids 0 to (MAX_MVCLIENTS-1) to be updated with extra info
+	if ( id >= MAX_MVCLIENTS ) {
+		return( qtrue );
+	}
+
+	tps = &ent->target_ent->client->ps;
+
+	if ( tps->stats[STAT_PLAYER_CLASS] == PC_ENGINEER ) {
+		chargeTime = g_engineerChargeTime.value;
+	} else if ( tps->stats[STAT_PLAYER_CLASS] == PC_MEDIC ) {
+		chargeTime = g_medicChargeTime.value;
+	} else if ( tps->stats[STAT_PLAYER_CLASS] == PC_LT )                                                                                                {
+		chargeTime = g_LTChargeTime.value;;
+	} else { chargeTime = g_soldierChargeTime.value;}
+
+	chargeTime = ( level.time - tps->classWeaponTime >= (int)chargeTime ) ? 0 : ( 1 + floor( 15.0f * (float)( level.time - tps->classWeaponTime ) / chargeTime ) );
+	sprintTime = ( ent->target_ent->client->ps.sprintTime >= 20000 ) ? 0.0f : ( 1 + floor( 7.0f * (float)ent->target_ent->client->ps.sprintTime / 20000.0f ) );
+	weapHeat   = floor( (float)tps->curWeapHeat * 15.0f / 255.0f );
+	hintTime   = ( tps->serverCursorHint != HINT_BUILD && ( tps->serverCursorHintVal >= 255 || tps->serverCursorHintVal == 0 ) ) ?
+				 0 : ( 1 + floor( 15.0f * (float)tps->serverCursorHintVal / 255.0f ) );
+
+	// (Remaining bits)
+	// ammo      : 0
+	// ammo-1    : 0
+	// ammiclip  : 0
+	// ammoclip-1: 16
+	id = MAX_WEAPONS - 1 - ( id * 2 );
+
+	if ( tps->pm_flags & PMF_LIMBO ) {
+		ps->ammo[id] = 0;
+		ps->ammo[id - 1] = 0;
+		ps->ammoclip[id - 1] = 0;
+	} else {
+		ps->ammo[id]  = ( ( ( ent->target_ent->health > 0 ) ? ent->target_ent->health : 0 ) & 0xFF ); // Meds up to 140 :(
+		ps->ammo[id] |= ( hintTime & 0x0F ) << 8; // 4 bits for work on current item (dynamite, weapon repair, etc.)
+		ps->ammo[id] |= ( weapHeat & 0x0F ) << 12; // 4 bits for weapon heat info
+
+		ps->ammo[id - 1]  = tps->ammo[BG_FindAmmoForWeapon( tps->weapon )] & 0x3FF;   // 11 bits needed to cover 1500 Venom ammo
+		ps->ammo[id - 1] |= ( BG_simpleWeaponState( tps->weaponstate ) & 0x03 ) << 11;  // 2 bits for current weapon state
+		ps->ammo[id - 1] |= ( ( tps->persistant[PERS_HWEAPON_USE] ) ? 1 : 0 ) << 13;    // 1 bit for mg42 use
+		ps->ammo[id - 1] |= ( BG_simpleHintsCollapse( tps->serverCursorHint, hintTime ) & 0x03 ) << 14; // 2 bits for cursor hints
+
+//	G_Printf("tps->hint: %d, dr: %d, collapse: %d\n", tps->serverCursorHint, HINT_DOOR_ROTATING, G_simpleHintsCollapse(tps->serverCursorHint, hintTime));
+
+		ps->ammoclip[id - 1]  = tps->ammoclip[BG_FindClipForWeapon( tps->weapon )] & 0x1FF;   // 9 bits to cover 500 Venom ammo clip
+		ps->ammoclip[id - 1] |= ( chargeTime & 0x0F ) << 9;   // 4 bits for weapon charge time
+		ps->ammoclip[id - 1] |= ( sprintTime & 0x07 ) << 13;  // 3 bits for fatigue
+	}
+
+	return( qtrue );
+}
Index: game/g_session.c
===================================================================
--- game/g_session.c	(revision 308)
+++ game/g_session.c	(working copy)
@@ -109,6 +109,7 @@
 ================
 */
 void G_ReadSessionData( gclient_t *client ) {
+	int mvc_l, mvc_h;	// OSPx - Multiview
 	char	s[MAX_STRING_CHARS];
 	const char	*var;
 	qboolean test;
@@ -116,7 +117,7 @@
 	var = va( "session%i", client - level.clients );
 	trap_Cvar_VariableStringBuffer( var, s, sizeof(s) );
 
-	sscanf( s, "%i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %s %i %i %i %i %i",		// DHM - Nerve
+	sscanf( s, "%i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %s %i %i %i %i %i %i %i",		// DHM - Nerve
 		(int *)&client->sess.sessionTeam,
 		&client->sess.spectatorTime,
 		(int *)&client->sess.spectatorState,
@@ -146,10 +147,16 @@
 		&client->sess.clientFlags,
 		&client->sess.specInvited,
 		&client->sess.specLocked,
-		&client->sess.uci
+		&client->sess.uci,
+		&mvc_l,
+		&mvc_h
 
 		);
 
+	// OSP -- reinstate MV clients
+	client->pers.mvReferenceList = (mvc_h << 16) | mvc_l;
+	// OSP
+
 	// NERVE - SMF
 	if ( g_altStopwatchMode.integer )	
 		test = qtrue;
Index: game/g_team.c
===================================================================
--- game/g_team.c	(revision 324)
+++ game/g_team.c	(working copy)
@@ -1765,13 +1765,17 @@
 			continue;
 		}
 
-		if (ent->client->sess.spectatorState == SPECTATOR_FOLLOW) {
+		if (ent->client->pers.mvCount > 0) {
+			G_smvRemoveInvalidClients(ent, nTeam);
+		} else if (ent->client->sess.spectatorState == SPECTATOR_FOLLOW) {
 			StopFollowing(ent);
 			ent->client->sess.specLocked &= ~nTeam;
 		}
 
-		// ClientBegin sets blackout		
-		SetTeam(ent, "s", qtrue);
+		// ClientBegin sets blackout
+		if (ent->client->pers.mvCount < 1) {
+			SetTeam(ent, "s", qtrue);
+		}
 	}
 }
 
@@ -1949,3 +1953,8 @@
 	level.cnNum = 0; // Resets countdown
 	trap_SetConfigstring(CS_READY, va("%i", READY_NONE));
 }
+
+// Returns player's "real" team.
+int G_teamID(gentity_t *ent) {	
+	return(ent->client->sess.sessionTeam);
+}
